##--------------------------------------------------------------------
## Node
##--------------------------------------------------------------------
node {
  ## Node name.
  ##
  ## See: http://erlang.org/doc/reference_manual/distributed.html
  ##
  ## Value: <name>@<host>
  ##
  ## Default: emqx@127.0.0.1
  name: "emqx@127.0.0.1"

  ## Cookie for distributed node communication.
  ##
  ## Value: String
  cookie: emqxsecretcookie

  ## Data dir for the node
  ##
  ## Value: Folder
  data_dir: "{{ platform_data_dir }}"

  ## Global GC Interval.
  ##
  ## Value: Duration
  ##
  ## Examples:
  ##  - 2h:  2 hours
  ##  - 30m: 30 minutes
  ##  - 20s: 20 seconds
  ##
  ## Defaut: 15 minutes
  global_gc_interval: 15m

  ## Tweak GC to run more often.
  ##
  ## Value: Number [0-65535]
  ##
  ## vm.args: -env ERL_FULLSWEEP_AFTER Number
  #fullsweep_after: 1000

  ## Crash dump log file.
  ##
  ## Value: Log file
  crash_dump: "{{ platform_log_dir }}/crash.dump"
}

##--------------------------------------------------------------------
## Cluster
##--------------------------------------------------------------------
cluster {

  ## Cluster name.
  ##
  ## Value: String
  name: emqxcl

  ## Specify the erlang distributed protocol.
  ##
  ## Value: Enum
  ##  - inet_tcp: the default; handles TCP streams with IPv4 addressing.
  ##  - inet6_tcp: handles TCP with IPv6 addressing.
  ##  - inet_tls: using TLS for Erlang Distribution.
  ##
  ## vm.args: -proto_dist inet_tcp
  proto_dist: inet_tcp

  ## Cluster auto-discovery strategy.
  ##
  ## Value: Enum
  ## - manual: Manual join command
  ## - static: Static node list
  ## - mcast:  IP Multicast
  ## - dns:    DNS A Record
  ## - etcd:   etcd
  ## - k8s:    Kubernetes
  ##
  ## Default: manual
  discovery: manual

  ## Enable cluster autoheal from network partition.
  ##
  ## Value: on | off
  ##
  ## Default: on
  autoheal: on

  ## Autoclean down node. A down node will be removed from the cluster
  ## if this value > 0.
  ##
  ## Value: Duration
  ## -h: hour, e.g. '2h' for 2 hours
  ## -m: minute, e.g. '5m' for 5 minutes
  ## -s: second, e.g. '30s' for 30 seconds
  ##
  ## Default: 5m
  autoclean: 5m

  ##------------------------------------------------------------------
  ## Cluster using static node list
  ##------------------------------------------------------------------
  ## Node list of the cluster
  ##
  ## Value: String
  ##
  #static_seeds:
  #   - emqx1@127.0.0.1
  #   - emqx2@127.0.0.1

  ##------------------------------------------------------------------
  ## Cluster using IP Multicast
  ##------------------------------------------------------------------
  ## IP Multicast Address.
  ##
  ## Value: IP Address
  #mcast_addr: 239.192.0.1

  ## Multicast Ports.
  ##
  ## Value: Port List
  #mcast_ports: 4369,4370

  ## Multicast Iface.
  ##
  ## Value: Iface Address
  ##
  ## Default: 0.0.0.0
  #mcast_iface: 0.0.0.0

  ## Multicast Ttl.
  ##
  ## Value: 0-255
  #mcast_ttl: 255

  ## Multicast loop.
  ##
  ## Value: on | off
  #mcast_loop: on

  ##------------------------------------------------------------------
  ## Cluster using DNS A records
  ##------------------------------------------------------------------
  ## DNS name.
  ##
  ## Value: String
  #dns_name: localhost

  ## The App name is used to build 'node.name' with IP address.
  ##
  ## Value: String
  #dns_app: emqx

  ##------------------------------------------------------------------
  ## Cluster using etcd
  ##------------------------------------------------------------------
  ## Etcd server list, seperated by ','.
  ##
  ## Value: String
  #etcd_server: http://127.0.0.1:2379

  ## The prefix helps build nodes path in etcd. Each node in the cluster
  ## will create a path in etcd: v2/keys/<prefix>/<name>/<node.name>
  ##
  ## Value: String
  #etcd_prefix: emqxcl

  ## The TTL for node's path in etcd.
  ##
  ## Value: Duration
  ##
  ## Default: 1m, 1 minute
  #etcd_node_ttl: 1m

  ## Path to a file containing the client's private PEM-encoded key.
  ##
  ## Value: File
  #etcd_ssl.keyfile: "{{ platform_etc_dir }}/certs/client-key.pem"

  ## The path to a file containing the client's certificate.
  ##
  ## Value: File
  #etcd_ssl.certfile: "{{ platform_etc_dir }}/certs/client.pem"

  ## Path to the file containing PEM-encoded CA certificates. The CA certificates
  ## are used during server authentication and when building the client certificate chain.
  ##
  ## Value: File
  ## etcd_ssl.cacertfile: "{{ platform_etc_dir }}/certs/ca.pem"

  ##------------------------------------------------------------------
  ## Cluster using Kubernetes
  ##------------------------------------------------------------------
  ## Kubernetes API server list, seperated by ','.
  ##
  ## Value: String
  #k8s_apiserver: "http://10.110.111.204:8080"

  ## The service name helps lookup EMQ nodes in the cluster.
  ##
  ## Value: String
  #k8s_service_name: emqx

  ## The address type is used to extract host from k8s service.
  ##
  ## Value: ip | dns | hostname
  #k8s_address_type: ip

  ## The app name helps build 'node.name'.
  ##
  ## Value: String
  #k8s_app_name: emqx

  ## The suffix added to dns and hostname get from k8s service
  ##
  ## Value: String
  #k8s_suffix: pod.local

  ## Kubernetes Namespace
  ##
  ## Value: String
  #k8s_namespace: default
}

##--------------------------------------------------------------------
## Log
##--------------------------------------------------------------------
log {
  ## This is the global log level:
  ##
  ## - all the log messages with levels lower than this level will be
  ##   dropped.
  ## - all the log messages with levels higher than this level will go
  ##   into the log handlers. The handlers then decide to log it out or
  ##   drop it according to the level setting of the handler.
  ##
  ## Value: debug | info | notice | warning | error |
  ##        critical | alert | emergency
  ##
  ## Note: Only the messages with severity level higher than or equal to
  ##       this level will be logged.
  ##
  ## Default: warning
  level: warning

  ## The log filename for specified level.
  ##
  ## If `rotation` is enabled, this is the base name of the
  ## files. Each file in a rotated log is named <base_name>.N, where N is an integer:
  ##
  ## files:
  ##   <level>:
  ##      - <filename>
  ##      - <filename>
  ##
  ## where "<level>" can be one of:
  ##    all, debug, info, notice, warning,
  ##    error, critical, alert, emergency
  ##
  ## Note: Log files for a specific log level will only contain all the logs
  ##       that higher than or equal to that level
  ##
  ## Value: String
  ## Default: emqx.log

  ## file log handlers send log messages to files
  handlers.file: [
    {
      ## The log level of this handler
      ## All the log messages with levels lower than this level will
      ## be dropped.
      level: all

      ## The dir for log files.
      ##
      ## Value: Folder
      filepath: "{{ platform_log_dir }}/emqx.log"

      ## Enables the log rotation.
      ## With this enabled, new log files will be created when the current
      ## log file is full, max to `rotation.size` files will be created.
      ##
      ## Value: on | off
      ## Default: on
      #rotation: on

      ## Maximum size of each log file.
      ##
      ## Value: Number
      ## Default: 10M
      ## Supported Unit: KB | MB | GB
      #rotation_size: 10MB

      ## Maximum rotation count of log files.
      ##
      ## Value: Number
      ## Default: 5
      #rotation_count: 5
    },
    #{
    #  level: error
    #  filepath: "{{ platform_log_dir }}/emqx.error.log"
    #}
  ]

  ## console log handlers send log messages to emqx console
  #handlers.console: {
    ## The log level of this handler
    ## All the log messages with levels lower than this level will
    ## be dropped.
    #level: all
  #}

  ## Limits the total number of characters printed for each log event.
  ##
  ## Value: Integer
  ## Default: No Limit
  #chars_limit: 8192

  ## The max allowed queue length before switching to sync mode.
  ##
  ## Log overload protection parameter. If the message queue grows
  ## larger than this value the handler switches from anync to sync mode.
  ##
  ## Default: 100
  ##
  #sync_mode_qlen: 100

  ## The max allowed queue length before switching to drop mode.
  ##
  ## Log overload protection parameter. When the message queue grows
  ## larger than this threshold, the handler switches to a mode in which
  ## it drops all new events that senders want to log.
  ##
  ## Default: 3000
  ##
  #drop_mode_qlen: 3000

  ## The max allowed queue length before switching to flush mode.
  ##
  ## Log overload protection parameter. If the length of the message queue
  ## grows larger than this threshold, a flush (delete) operation takes place.
  ## To flush events, the handler discards the messages in the message queue
  ## by receiving them in a loop without logging.
  ##
  ## Default: 8000
  ##
  #flush_qlen: 8000

  ## Kill the log handler when it gets overloaded.
  ##
  ## Log overload protection parameter. It is possible that a handler,
  ## even if it can successfully manage peaks of high load without crashing,
  ## can build up a large message queue, or use a large amount of memory.
  ## We could kill the log handler in these cases and restart it after a
  ## few seconds.
  ##
  ## Default: on
  ##
  #overload_kill: on

  ## The max allowed queue length before killing the log hanlder.
  ##
  ## Log overload protection parameter. This is the maximum allowed queue
  ## length. If the message queue grows larger than this, the handler
  ## process is terminated.
  ##
  ## Default: 20000
  ##
  #overload_kill_qlen: 20000

  ## The max allowed memory size before killing the log hanlder.
  ##
  ## Log overload protection parameter. This is the maximum memory size
  ## that the handler process is allowed to use. If the handler grows
  ## larger than this, the process is terminated.
  ##
  ## Default: 30MB
  ##
  #overload_kill_mem_size: 30MB

  ## Restart the log hanlder after some seconds.
  ##
  ## Log overload protection parameter. If the handler is terminated,
  ## it restarts automatically after a delay specified in seconds.
  ## The value "infinity" prevents restarts.
  ##
  ## Default: 5s
  ##
  #overload_kill_restart_after: 5s

  ## Max burst count and time window for burst control.
  ##
  ## Log overload protection parameter. Large bursts of log events - many
  ## events received by the handler under a short period of time - can
  ## potentially cause problems. By specifying the maximum number of events
  ## to be handled within a certain time frame, the handler can avoid
  ## choking the log with massive amounts of printouts.
  ##
  ## This config controls the maximum number of events to handle within
  ## a time frame. After the limit is reached, successive events are
  ## dropped until the end of the time frame.
  ##
  ## Note that there would be no warning if any messages were
  ## dropped because of burst control.
  ##
  ## Comment this config out to disable the burst control feature.
  ##
  ## Value: MaxBurstCount,TimeWindow
  ## Default: disabled
  ##
  #burst_limit: 20000, 1s
}

##--------------------------------------------------------------------
## RPC
##--------------------------------------------------------------------
rpc {
  ## RPC Mode.
  ##
  ## Value: sync | async
  mode: async

  ## Max batch size of async RPC requests.
  ##
  ## Value: Integer
  ## Zero or negative value disables rpc batching.
  ##
  ## NOTE: RPC batch won't work when mode: sync
  async_batch_size: 256

  ## RPC port discovery
  ##
  ## The strategy for discovering the RPC listening port of other nodes.
  ##
  ## Value: Enum
  ## - manual: discover ports by `tcp_server_port` and `tcp_client_port`.
  ## - stateless: discover ports in a stateless manner.
  ##   If node name is `emqx<N>@127.0.0.1`, where the `<N>` is an integer,
  ##   then the listening port will be `5370 + <N>`
  ##
  ## Defaults to `stateless`.
  port_discovery: stateless

  ## Number of outgoing RPC connections.
  ##
  ## Value: Interger [1-256]
  ## Defaults to NumberOfCPUSchedulers / 2
  tcp_client_num: 1

  ## TCP server port for RPC.
  ##
  ## Only takes effect when `port_discovery`: `manual`.
  ##
  ## Value: Port [1024-65535]
  #tcp_server_port: 5369

  ## TCP port for outgoing RPC connections.
  ##
  ## Only takes effect when `port_discovery`: `manual`.
  ##
  ## Value: Port [1024-65535]
  #tcp_client_port: 5369

  ## RCP Client connect timeout.
  ##
  ## Value: Seconds
  #connect_timeout: 5s

  ## TCP send timeout of RPC client and server.
  ##
  ## Value: Seconds
  #send_timeout: 5s

  ## Authentication timeout
  ##
  ## Value: Seconds
  #authentication_timeout: 5s

  ## Default receive timeout for call() functions
  ##
  ## Value: Seconds
  #call_receive_timeout: 15s

  ## Socket idle keepalive.
  ##
  ## Value: Seconds
  #socket_keepalive_idle: 900s

  ## TCP Keepalive probes interval.
  ##
  ## Value: Seconds
  #socket_keepalive_interval: 75s

  ## Probes lost to close the connection
  ##
  ## Value: Integer
  #socket_keepalive_count: 9

  ## Size of TCP send buffer.
  ##
  ## Value: Bytes
  #socket_sndbuf: 1MB

  ## Size of TCP receive buffer.
  ##
  ## Value: Seconds
  #socket_recbuf: 1MB

  ## Size of user-level software socket buffer.
  ##
  ## Value: Seconds
  #socket_buffer: 1MB
}

##--------------------------------------------------------------------
## Broker
##--------------------------------------------------------------------
broker {
  ## System interval of publishing $SYS messages.
  ##
  ## Value: Duration
  ## Default: 1m, 1 minute
  sys_msg_interval: 1m

  ## System heartbeat interval of publishing following heart beat message:
  ##  - "$SYS/brokers/<node>/uptime"
  ##  - "$SYS/brokers/<node>/datetime"
  ##
  ## Value: Duration
  ## Default: 30s
  sys_heartbeat_interval: 30s

  ## Session locking strategy in a cluster.
  ##
  ## Value: Enum
  ## - local
  ## - one
  ## - quorum
  ## - all
  session_locking_strategy: quorum

  ## Dispatch strategy for shared subscription
  ##
  ## Value: Enum
  ## - random
  ## - round_robin
  ## - sticky
  ## - hash
  shared_subscription_strategy: random

  ## Enable/disable shared dispatch acknowledgement for QoS1 and QoS2 messages
  ## This should allow messages to be dispatched to a different subscriber in
  ## the group in case the picked (based on shared_subscription_strategy) one # is offline
  ##
  ## Value: Enum
  ## - true
  ## - false
  shared_dispatch_ack_enabled: false

  ## Enable batch clean for deleted routes.
  ##
  ## Value: Flag
  route_batch_clean: off
}

##--------------------------------------------------------------------
## Listeners
##--------------------------------------------------------------------
## MQTT/TCP - TCP Listener for MQTT Protocol
listeners tcp {
  ## The IP address and port that the listener will bind.
  ##
  ## Value: IP:Port | Port
  ##
  ## Examples: 1883, 127.0.0.1:1883, ::1:1883
  bind: "0.0.0.0:1883"

  ## The MQTT connection configs this listener will use.
  ##
  ## All the clients connected to this listener will use the MQTT
  ## configs defined by the specific zone name.
  ##
  ## See 'mqtt.yaml' for details of all MQTT zones.
  ##
  ## It will use the 'default' zone if not set.
  zone: default

  ## The acceptor pool for this listener.
  ##
  ## Value: Number
  acceptors: 8

  ## Maximum connections per second.
  ##
  ## Value: Number
  max_conn_rate: 1000

  ## Maximum number of concurrent connections.
  ##
  ## Value: Number
  max_connections: 1024000

  ## The access control rules for this listener.
  ##
  ## See: https://github.com/emqtt/esockd#allowdeny
  ##
  ## Value: ACL Rule
  ##
  ## Example:
  ##
  ## access_rules: [
  ##   allow 192.168.0.0/24
  ## ]
  #access_rules: [
  #    allow all
  #]

  ## Specify the {active, N} option for this Socket.
  ##
  ## Value: Number
  #active_n: 100

  ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
  ## behind HAProxy or Nginx.
  ##
  ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
  ##
  ## Value: on | off
  #proxy_protocol: on

  ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
  ## if no proxy protocol packet recevied within the timeout.
  ##
  ## Value: Duration
  #proxy_protocol_timeout: 3s

  ## TCP Options
  ## This will override the global 'tcp_options' config
  #tcp_options: {
    #backlog: 1024
    #send_timeout: 15s
  #}
}

## MQTT/SSL - SSL Listener for MQTT Protocol
listeners ssl {
  ## The IP address and port this listener will bind.
  ##
  ## Value: IP:Port | Port
  ##
  ## Examples: 8883, 127.0.0.1:8883, ::1:8883
  bind: 8883

  ## The MQTT connection configs this listener will use.
  ##
  ## All the clients connected to this listener will use the MQTT
  ## configs defined by the specific zone name.
  ##
  ## See 'mqtt.yaml' for details of all MQTT zones.
  ##
  ## It will use the 'default' zone if not set.
  zone: default

  ## The acceptor pool for this listener.
  ##
  ## Value: Number
  acceptors: 16

  ## Maximum connections per second.
  ##
  ## Value: Number
  max_conn_rate: 1000

  ## Maximum number of concurrent connections.
  ##
  ## Value: Number
  max_connections: 102400

  ## Specify the {active, N} option for the Socket.
  ##
  ## Value: Number
  #active_n: 100

  ## The access control rules for this listener.
  ##
  ## See: https://github.com/emqtt/esockd#allowdeny
  ##
  ## Value: ACL Rule
  ##
  ## Example:
  ##
  ## access_rules: [
  ##   allow 192.168.0.0/24
  ## ]
  #access_rules: [
  #    allow all
  #]

  ## Enable the Proxy Protocol V1/2 if the EMQ cluster is deployed behind
  ## HAProxy or Nginx.
  ##
  ## Value: on | off
  #proxy_protocol: on

  ## Sets the timeout for proxy protocol.
  ##
  ## See: listener.tcp.$name.proxy_protocol_timeout
  ##
  ## Value: Duration
  #proxy_protocol_timeout: 3s

  include socket.conf
  ## SSL Options
  ## This will override the global 'ssl_options' config
  #ssl_options {
    #keyfile: "{{ platform_etc_dir }}/certs/key.pem"
    #certfile: "{{ platform_etc_dir }}/certs/cert.pem"
    #cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"
  #}

  ## TCP Options
  ## This will override the global 'tcp_options' config
  #tcp_options: {
    #backlog: 1024
    #send_timeout: 15s
  #}
}

listeners tcp {
  bind: "127.0.0.1:11883"
  zone: internal
  acceptors: 4
  max_connections: 1024000
  max_conn_rate: 1000
  active_n: 1000
  tcp_options {
    backlog: 512
    send_timeout: 5s
    send_timeout_close: on
    recbuf: 64KB
    sndbuf: 64KB
    buffer: 16KB
  }
}


listeners ws {
  ## The IP address and port this listener will bind.
  ##
  ## Value: IP:Port | Port
  ##
  ## Examples: 8083, 127.0.0.1:8083, ::1:8083
  bind: 8083

  ## The MQTT connection configs this listener will use.
  ##
  ## All the clients connected to this listener will use the MQTT
  ## configs defined by the specific zone name.
  ##
  ## See 'mqtt.yaml' for details of all MQTT zones.
  ##
  ## It will use the 'default' zone if not set.
  zone: default

  ## The path of WebSocket MQTT endpoint
  ##
  ## Value: URL Path
  mqtt_path: /mqtt

  ## The acceptor pool for this listener.
  ##
  ## Value: Number
  acceptors: 4

  ## Maximum connections per second.
  ##
  ## Value: Number
  max_conn_rate: 1000

  ## Maximum number of concurrent connections.
  ##
  ## Value: Number
  max_connections: 102400

  ## Simulate the {active, N} option for the connections.
  ##
  ## Value: Number
  #active_n: 100

  ## The access control rules for this listener.
  ##
  ## See: https://github.com/emqtt/esockd#allowdeny
  ##
  ## Value: ACL Rule
  ##
  ## Example:
  ##
  ## access_rules: [
  ##   allow 192.168.0.0/24
  ## ]
  #access_rules: [
  #    allow all
  #]

  ## Enable the Proxy Protocol V1/2 if the EMQ cluster is deployed behind
  ## HAProxy or Nginx.
  ##
  ## Value: on | off
  #proxy_protocol: on

  ## Sets the timeout for proxy protocol.
  ##
  ## Value: Duration
  #proxy_protocol_timeout: 3s

  ## Whether a WebSocket message is allowed to contain multiple MQTT packets
  ##
  ## Value: single | multiple
  #mqtt_piggyback: multiple

  ## TCP Options
  ## This will override the global 'tcp_options' config
  #tcp_options {
    #backlog: 1024
    #send_timeout: 15s
  #}

  ## TCP Options
  ## This will override the global 'websocket_options' config
  #websocket_options: {
    #compress: true
    #max_frame_size: 0
  #}
}

listeners wss {
  ## The IP address and port this listener will bind.
  ##
  ## Value: IP:Port | Port
  ##
  ## Examples: 8084, 127.0.0.1:8084, ::1:8084
  bind: 8084

  ## The MQTT connection configs this listener will use.
  ##
  ## All the clients connected to this listener will use the MQTT
  ## configs defined by the specific zone name.
  ##
  ## See 'mqtt.yaml' for details of all MQTT zones.
  ##
  ## It will use the 'default' zone if not set.
  zone: default

  ## The path of WebSocket MQTT endpoint
  ##
  ## Value: URL Path
  mqtt_path: /mqtt

  ## The acceptor pool for this listener.
  ##
  ## Value: Number
  acceptors: 4

  ## Maximum connections per second.
  ##
  ## Value: Number
  max_conn_rate: 1000

  ## Maximum number of concurrent connections.
  ##
  ## Value: Number
  max_connections: 102400

  ## Simulate the {active, N} option for the connections.
  ##
  ## Value: Number
  #active_n: 100

  ## The access control rules for this listener.
  ##
  ## See: https://github.com/emqtt/esockd#allowdeny
  ##
  ## Value: ACL Rule
  ##
  ## Example:
  ##
  ## access_rules: [
  ##   allow 192.168.0.0/24
  ## ]
  #access_rules: [
  #    allow all
  #]

  ## Enable the Proxy Protocol V1/2 support.
  ##
  ## Value: on | off
  #proxy_protocol: on

  ## Sets the timeout for proxy protocol.
  ##
  ## Value: Duration
  #proxy_protocol_timeout: 3s

  ## Whether a WebSocket message is allowed to contain multiple MQTT packets
  ##
  ## Value: single | multiple
  #mqtt_piggyback: multiple

  ## SSL Options
  ## This will override the global 'ssl_options' config
  #ssl_options {
    #keyfile: "{{ platform_etc_dir }}/certs/key.pem"
    #certfile: "{{ platform_etc_dir }}/certs/cert.pem"
    #cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"
  #}

  ## TCP Options
  ## This will override the global 'tcp_options' config
  #tcp_options {
    #backlog: 1024
    #send_timeout: 15s
  #}

  ## TCP Options
  ## This will override the global 'websocket_options' config
  #websocket_options {
    #compress: true
    #max_frame_size: 0
  #}
}

##--------------------------------------------------------------------
## Global Socket Options
##--------------------------------------------------------------------

## Socket options for TCP connections
tcp_options {
  ## TCP backlog for the connections.
  ##
  ## See listener.tcp.$name.backlog
  ##
  ## Value: Number >= 0
  #backlog: 1024

  ## The TCP send timeout for the connections.
  ##
  ## See listener.tcp.$name.send_timeout
  ##
  ## Value: Duration
  send_timeout: 15s

  ## Close the connection if send timeout.
  ##
  ## See: listener.tcp.$name.send_timeout_close
  ##
  ## Value: on | off
  #send_timeout_close: on

  ## The TCP receive buffer(os kernel) for the connections.
  ##
  ## See: listener.tcp.$name.recbuf
  ##
  ## Value: Bytes
  recbuf: 4KB

  ## The TCP send buffer(os kernel) for the connections.
  ##
  ## See: listener.tcp.$name.sndbuf
  ##
  ## Value: Bytes
  sndbuf: 4KB

  ## The size of the user-level software buffer used by the driver.
  ##
  ## See: listener.tcp.$name.buffer
  ##
  ## Value: Bytes
  buffer: 4KB

  ## Sets the 'buffer: max(sndbuf, recbuf)' if this option is enabled.
  ##
  ## See: listener.tcp.$name.tune_buffer
  ##
  ## Value: on | off
  #tune_buffer: off

  ## The TCP_NODELAY flag for the connections.
  ##
  ## See: listener.tcp.$name.nodelay
  ##
  ## Value: true | false
  #nodelay: true

  ## The SO_REUSEADDR flag for the connections.
  ##
  ## Value: true | false
  #reuseaddr: true
}

## Socket options for SSL connections
ssl_options {
  ## A performance optimization setting, it allows clients to reuse
  ## pre-existing sessions, instead of initializing new ones.
  ## Read more about it here.
  ##
  ## See: http://erlang.org/doc/man/ssl.html
  ##
  ## Value: on | off
  reuse_sessions: on

  ## SSL parameter renegotiation is a feature that allows a client and a server
  ## to renegotiate the parameters of the SSL connection on the fly.
  ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
  ## you drop support for the insecure renegotiation, prone to MitM attacks.
  ##
  ## Value: on | off
  #secure_renegotiate: off

  ## An important security setting, it forces the cipher to be set based
  ## on the server-specified order instead of the client-specified order,
  ## hence enforcing the (usually more properly configured) security
  ## ordering of the server administrator.
  ##
  ## Value: on | off
  #honor_cipher_order: on

  ## TLS versions only to protect from POODLE attack.
  ##
  ## See: http://erlang.org/doc/man/ssl.html
  ##
  ## Value: String, seperated by ','
  ## tls_versions: tlsv1.2,tlsv1.1,tlsv1

  ## TLS Handshake timeout.
  ##
  ## Value: Duration
  handshake_timeout: 15s

  ## Path to the file containing the user's private PEM-encoded key.
  ##
  ## See: http://erlang.org/doc/man/ssl.html
  ##
  ## Value: File
  keyfile: "{{ platform_etc_dir }}/certs/key.pem"

  ## Path to a file containing the user certificate.
  ##
  ## See: http://erlang.org/doc/man/ssl.html
  ##
  ## Value: File
  certfile: "{{ platform_etc_dir }}/certs/cert.pem"

  ## Path to the file containing PEM-encoded CA certificates. The CA certificates
  ## are used during server authentication and when building the client certificate chain.
  ##
  ## Value: File
  cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"

  ## The Ephemeral Diffie-Helman key exchange is a very effective way of
  ## ensuring Forward Secrecy by exchanging a set of keys that never hit
  ## the wire. Since the DH key is effectively signed by the private key,
  ## it needs to be at least as strong as the private key. In addition,
  ## the default DH groups that most of the OpenSSL installations have
  ## are only a handful (since they are distributed with the OpenSSL
  ## package that has been built for the operating system it’s running on)
  ## and hence predictable (not to mention, 1024 bits only).
  ## In order to escape this situation, first we need to generate a fresh,
  ## strong DH group, store it in a file and then use the option above,
  ## to force our SSL application to use the new DH group. Fortunately,
  ## OpenSSL provides us with a tool to do that. Simply run:
  ## openssl dhparam -out dh-params.pem 2048
  ##
  ## Value: File
  #dhfile: "{{ platform_etc_dir }}/certs/dh-params.pem"

  ## A server only does x509-path validation in mode verify_peer,
  ## as it then sends a certificate request to the client (this
  ## message is not sent if the verify option is verify_none).
  ## You can then also want to specify option fail_if_no_peer_cert.
  ## More information at: http://erlang.org/doc/man/ssl.html
  ##
  ## Value: verify_peer | verify_none
  #verify: verify_peer

  ## Used together with {verify, verify_peer} by an SSL server. If set to true,
  ## the server fails if the client does not have a certificate to send, that is,
  ## sends an empty certificate.
  ##
  ## Value: true | false
  #fail_if_no_peer_cert: true

  ## This is the single most important configuration option of an Erlang SSL
  ## application. Ciphers (and their ordering) define the way the client and
  ## server encrypt information over the wire, from the initial Diffie-Helman
  ## key exchange, the session key encryption ## algorithm and the message
  ## digest algorithm. Selecting a good cipher suite is critical for the
  ## application’s data security, confidentiality and performance.
  ##
  ## The cipher list above offers:
  ##
  ## A good balance between compatibility with older browsers.
  ## It can get stricter for Machine-To-Machine scenarios.
  ## Perfect Forward Secrecy.
  ## No old/insecure encryption and HMAC algorithms
  ##
  ## Most of it was copied from Mozilla’s Server Side TLS article
  ##
  ## Value: Ciphers List
  ##
  ## If not set, following configuration will be used:
  ##
  ## ciphers:
  ##   - ECDHE-ECDSA-AES256-GCM-SHA384
  ##   - ECDHE-RSA-AES256-GCM-SHA384
  ##   - ECDHE-ECDSA-AES256-SHA384
  ##   - ECDHE-RSA-AES256-SHA384
  ##   - ECDHE-ECDSA-DES-CBC3-SHA
  ##   - ECDH-ECDSA-AES256-GCM-SHA384
  ##   - ECDH-RSA-AES256-GCM-SHA384
  ##   - ECDH-ECDSA-AES256-SHA384
  ##   - ECDH-RSA-AES256-SHA384
  ##   - DHE-DSS-AES256-GCM-SHA384
  ##   - DHE-DSS-AES256-SHA256
  ##   - AES256-GCM-SHA384
  ##   - AES256-SHA256
  ##   - ECDHE-ECDSA-AES128-GCM-SHA256
  ##   - ECDHE-RSA-AES128-GCM-SHA256
  ##   - ECDHE-ECDSA-AES128-SHA256
  ##   - ECDHE-RSA-AES128-SHA256
  ##   - ECDH-ECDSA-AES128-GCM-SHA256
  ##   - ECDH-RSA-AES128-GCM-SHA256
  ##   - ECDH-ECDSA-AES128-SHA256
  ##   - ECDH-RSA-AES128-SHA256
  ##   - DHE-DSS-AES128-GCM-SHA256
  ##   - DHE-DSS-AES128-SHA256
  ##   - AES128-GCM-SHA256
  ##   - AES128-SHA256
  ##   - ECDHE-ECDSA-AES256-SHA
  ##   - ECDHE-RSA-AES256-SHA
  ##   - DHE-DSS-AES256-SHA
  ##   - ECDH-ECDSA-AES256-SHA
  ##   - ECDH-RSA-AES256-SHA
  ##   - AES256-SHA
  ##   - ECDHE-ECDSA-AES128-SHA
  ##   - ECDHE-RSA-AES128-SHA
  ##   - DHE-DSS-AES128-SHA
  ##   - ECDH-ECDSA-AES128-SHA
  ##   - ECDH-RSA-AES128-SHA
  ##   - AES128-SHA
  ##
  #ciphers:
  #  - your-ciphers

  ## Ciphers for TLS PSK.
  ## Note that 'ciphers' and 'psk_ciphers' cannot
  ## be configured at the same time.
  ## See 'https://tools.ietf.org/html/rfc4279#section-2'.
  ## If not set, following configuration will be used:
  ##
  ## psk_ciphers:
  ##   - PSK-AES128-CBC-SHA
  ##   - PSK-AES256-CBC-SHA
  ##   - PSK-3DES-EDE-CBC-SHA
  ##   - PSK-RC4-SHA
  ##
  #psk_ciphers:
  #  - your-ciphers
}

## Socket options for websocket connections
websocket_options {
  ## The compress flag for external WebSocket connections.
  ##
  ## If this Value is set true,the websocket message would be compressed
  ##
  ## Value: true | false
  #compress: true

  ## The level of deflate options for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.level
  ##
  ## Value: none | default | best_compression | best_speed
  #deflate_opts.level: default

  ## The mem_level of deflate options for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.mem_level
  ##
  ## Valid range is 1-9
  #deflate_opts.mem_level: 8

  ## The strategy of deflate options for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.strategy
  ##
  ## Value: default | filtered | huffman_only | rle
  #deflate_opts.strategy: default

  ## The deflate option for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.server_context_takeover
  ##
  ## Value: takeover | no_takeover
  #deflate_opts.server_context_takeover: takeover

  ## The deflate option for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.client_context_takeover
  ##
  ## Value: takeover | no_takeover
  #deflate_opts.client_context_takeover: takeover

  ## The deflate options for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.server_max_window_bits
  ##
  ## Valid range is 8-15
  #deflate_opts.server_max_window_bits: 15

  ## The deflate options for external WebSocket connections.
  ##
  ## See: listener.ws.$name.deflate_opts.client_max_window_bits
  ##
  ## Valid range is 8-15
  #deflate_opts.client_max_window_bits: 15

  ## The idle timeout for external WebSocket connections.
  ##
  ## See: listener.ws.$name.idle_timeout
  ##
  ## Value: Duration
  idle_timeout: 60s

  ## The max frame size for external WebSocket connections.
  ##
  ##
  ## Value: Number
  #max_frame_size: 0
}

##--------------------------------------------------------------------
## System Monitor
##--------------------------------------------------------------------
#sysmon {
  ## The time interval for the periodic process limit check
  ##
  ## Value: Duration
  ##
  ## Default: 30s
  #process_check_interval: 30s

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is set.
  ##
  ## Default: 80%
  #process_high_watermark: 80%

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is clear.
  ##
  ## Default: 60%
  #process_low_watermark: 60%

  ## Enable Long GC monitoring. Disable if the value is 0.
  ## Notice: don't enable the monitor in production for:
  ## https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421
  ##
  ## Value: Duration
  ##  - h: hour
  ##  - m: minute
  ##  - s: second
  ##  - ms: milliseconds
  ##
  ## Examples:
  ##  - 2h:  2 hours
  ##  - 30m: 30 minutes
  ##  - 0.1s: 0.1 seconds
  ##  - 100ms : 100 milliseconds
  ##
  ## Default: 0ms
  #long_gc: 0

  ## Enable Long Schedule(ms) monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## Value: Duration
  ##  - h: hour
  ##  - m: minute
  ##  - s: second
  ##  - ms: milliseconds
  ##
  ## Examples:
  ##  - 2h:  2 hours
  ##  - 30m: 30 minutes
  ##  - 0.1s: 0.1 seconds
  ##  - 100ms: 100 milliseconds
  ##
  ## Default: 0ms
  #long_schedule: 240ms

  ## Enable Large Heap monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## Value: bytes
  ##
  ## Default: 8M words. 32MB on 32-bit VM, 64MB on 64-bit VM.
  #large_heap: 8MB

  ## Enable Busy Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## Value: true | false
  #busy_port: false

  ## Enable Busy Dist Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## Value: true | false
  #busy_dist_port: true

  ## The time interval for the periodic cpu check
  ##
  ## Value: Duration
  ## -h: hour, e.g. '2h' for 2 hours
  ## -m: minute, e.g. '5m' for 5 minutes
  ## -s: second, e.g. '30s' for 30 seconds
  ##
  ## Default: 60s
  #cpu_check_interval: 60s

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is set.
  ##
  ## Default: 80%
  #cpu_high_watermark: 80%

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is clear.
  ##
  ## Default: 60%
  #cpu_low_watermark: 60%

  ## The time interval for the periodic memory check
  ##
  ## Value: Duration
  ## -h: hour, e.g. '2h' for 2 hours
  ## -m: minute, e.g. '5m' for 5 minutes
  ## -s: second, e.g. '30s' for 30 seconds
  ##
  ## Default: 60s
  #mem_check_interval: 60s

  ## The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set.
  ##
  ## Default: 70%
  #sysmem_high_watermark: 70%

  ## The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set.
  ##
  ## Default: 5%
  #procmem_high_watermark: 5%
#}

##--------------------------------------------------------------------
## Alarm
##--------------------------------------------------------------------
#alarm {
  ## Specifies the actions to take when an alarm is activated
  ##
  ## Value: String
  ##  - log
  ##  - publish
  ##
  ## Default: log,publish
  #actions: log,publish

  ## The maximum number of deactivated alarms
  ##
  ## Value: Integer
  ##
  ## Default: 1000
  #size_limit: 1000

  ## Validity Period of deactivated alarms
  ##
  ## Value: Duration
  ##  - h: hour
  ##  - m: minute
  ##  - s: second
  ##  - ms: milliseconds
  ##
  ## Default: 24h
  #validity_period: 24h
#}
