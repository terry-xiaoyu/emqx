## master-88df1713

## NOTE: The configurations in this file will be overridden by
## `<path-to-emqx-installation>/etc/emqx_overrides.conf`

##==================================================================
## Node
##==================================================================
node {
  ## Node name.
  ## See: http://erlang.org/doc/reference_manual/distributed.html
  ##
  ## @doc node.name
  ## ValueType: NodeName
  ## Default: emqx@127.0.0.1
  name: "emqx@127.0.0.1"

  ## Cookie for distributed node communication.
  ##
  ## @doc node.cookie
  ## ValueType: String
  ## Default: emqxsecretcookie
  cookie: emqxsecretcookie

  ## Data dir for the node
  ##
  ## @doc node.data_dir
  ## ValueType: Folder
  ## Default: "{{ platform_data_dir }}/"
  data_dir: "{{ platform_data_dir }}/"

  ## Dir of crash dump file.
  ##
  ## @doc node.crash_dump_dir
  ## ValueType: Folder
  ## Default: "{{ platform_log_dir }}/"
  #crash_dump_dir: "{{ platform_log_dir }}/"

  ## Global GC Interval.
  ##
  ## @doc node.global_gc_interval
  ## ValueType: Duration
  ## Default: 15m
  #global_gc_interval: 15m

  ## Sets the net_kernel tick time in seconds.
  ## Notice that all communicating nodes are to have the same
  ## TickTime value specified.
  ##
  ## See: http://www.erlang.org/doc/man/kernel_app.html#net_ticktime
  ##
  ## @doc node.dist_net_ticktime
  ## ValueType: Number
  ## Default: 15m
  ## dist_net_ticktime = 120

  ## Sets the port range for the listener socket of a distributed
  ## Erlang node.
  ## Note that if there are firewalls between clustered nodes, this
  ## port segment for nodes’ communication should be allowed.
  ##
  ## See: http://www.erlang.org/doc/man/kernel_app.html
  ##
  ## @doc node.dist_listen_min
  ## ValueType: Integer
  ## Range: [1024,65535]
  ## Default: 6369
  node.dist_listen_min = 6369

  ## Sets the port range for the listener socket of a distributed
  ## Erlang node.
  ## Note that if there are firewalls between clustered nodes, this
  ## port segment for nodes’ communication should be allowed.
  ##
  ## See: http://www.erlang.org/doc/man/kernel_app.html
  ##
  ## @doc node.dist_listen_max
  ## ValueType: Integer
  ## Range: [1024,65535]
  ## Default: 6369
  node.dist_listen_max = 6369

  ## Sets the maximum depth of call stack back-traces in the exit
  ## reason element of 'EXIT' tuples.
  ## The flag also limits the stacktrace depth returned by
  ## process_info item current_stacktrace.
  ##
  ## @doc node.backtrace_depth
  ## ValueType: Integer
  ## Range: [0,1024]
  ## Default: 16
  node.backtrace_depth = 16

}

##==================================================================
## Cluster
##==================================================================
cluster {
  ## Cluster name.
  ##
  ## @doc cluster.name
  ## ValueType: String
  ## Default: emqxcl
  name: emqxcl

  ## Enable cluster autoheal from network partition.
  ##
  ## @doc cluster.autoheal
  ## ValueType: Boolean
  ## Default: true
  autoheal: true

  ## Autoclean down node. A down node will be removed from the cluster
  ## if this value > 0.
  ##
  ## @doc cluster.autoclean
  ## ValueType: Duration
  ## Default: 5m
  autoclean: 5m

  ## Node discovery strategy to join the cluster.
  ##
  ## @doc cluster.discovery_strategy
  ## ValueType: manual | static | mcast | dns | etcd | k8s
  ##   - manual: Manual join command
  ##   - static: Static node list
  ##   - mcast:  IP Multicast
  ##   - dns:    DNS A Record
  ##   - etcd:   etcd
  ##   - k8s:    Kubernetes
  ##
  ## Default: manual
  discovery_strategy: manual

  ##----------------------------------------------------------------
  ## Cluster using static node list
  ##----------------------------------------------------------------
  #static {
    ## Node list of the cluster
    ##
    ## @doc cluster.static.seeds
    ## ValueType: Array<NodeName>
    ## Default: ["emqx1@127.0.0.1", "emqx2@127.0.0.1"]
    #seeds: ["emqx1@127.0.0.1", "emqx2@127.0.0.1"]
  #}

  ##----------------------------------------------------------------
  ## Cluster using IP Multicast
  ##----------------------------------------------------------------
  #mcast {
    ## IP Multicast Address.
    ##
    ## @doc cluster.mcast.addr
    ## ValueType: IPAddress
    ## Default: 239.192.0.1
    #addr: 239.192.0.1

    ## Multicast Ports.
    ##
    ## @doc cluster.mcast.ports
    ## ValueType: Array<Port>
    ## Default: [4369, 4370]
    #ports: [4369, 4370]

    ## Multicast Iface.
    ##
    ## @doc cluster.mcast.iface
    ## ValueType: IPAddress
    ## Default: 0.0.0.0
    #iface: 0.0.0.0

    ## Multicast Ttl.
    ##
    ## @doc cluster.mcast.ttl
    ## ValueType: Integer
    ## Range: [0,255]
    ## Default: 255
    #ttl: 255

    ## Multicast loop.
    ##
    ## @doc cluster.mcast.loop
    ## ValueType: Boolean
    ## Default: true
    #loop: true
  #}

  ##----------------------------------------------------------------
  ## Cluster using DNS A records
  ##----------------------------------------------------------------
  #dns {
    ## DNS name.
    ##
    ## @doc cluster.dns.name
    ## ValueType: String
    ## Default: localhost
    #name: localhost

    ## The App name is used to build 'node.name' with IP address.
    ##
    ## @doc cluster.dns.app
    ## ValueType: String
    ## Default: emqx
    #app: emqx
  #}

  ##----------------------------------------------------------------
  ## Cluster using etcd
  ##----------------------------------------------------------------
  #etcd {
    ## Etcd server list, seperated by ','.
    ##
    ## @doc cluster.etcd.server
    ## ValueType: URL
    ## Required: true
    #server: http://127.0.0.1:2379

    ## The prefix helps build nodes path in etcd. Each node in the cluster
    ## will create a path in etcd: v2/keys/<prefix>/<name>/<node.name>
    ##
    ## @doc cluster.etcd.prefix
    ## ValueType: String
    ## Default: emqxcl
    #prefix: emqxcl

    ## The TTL for node's path in etcd.
    ##
    ## @doc cluster.etcd.node_ttl
    ## ValueType: Duration
    ## Default: 1m
    #node_ttl: 1m

    ## Path to the file containing the user's private PEM-encoded key.
    ##
    ## @doc cluster.etcd.ssl.keyfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/key.pem"
    #ssl.keyfile: "{{ platform_etc_dir }}/certs/key.pem"

    ## Path to a file containing the user certificate.
    ##
    ## @doc cluster.etcd.ssl.certfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cert.pem"
    #ssl.certfile: "{{ platform_etc_dir }}/certs/cert.pem"

    ## Path to the file containing PEM-encoded CA certificates. The CA certificates
    ## are used during server authentication and when building the client certificate chain.
    ##
    ## @doc cluster.etcd.ssl.cacertfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cacert.pem"
    #ssl.cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"
  #}

  ##----------------------------------------------------------------
  ## Cluster using Kubernetes
  ##----------------------------------------------------------------
  #k8s {
    ## Kubernetes API server list, seperated by ','.
    ##
    ## @doc cluster.k8s.apiserver
    ## ValueType: URL
    ## Required: true
    #apiserver: "http://10.110.111.204:8080"

    ## The service name helps lookup EMQ nodes in the cluster.
    ##
    ## @doc cluster.k8s.service_name
    ## ValueType: String
    ## Default: emqx
    #service_name: emqx

    ## The address type is used to extract host from k8s service.
    ##
    ## @doc cluster.k8s.address_type
    ## ValueType: ip | dns | hostname
    ## Default: ip
    #address_type: ip

    ## The app name helps build 'node.name'.
    ##
    ## @doc cluster.k8s.app_name
    ## ValueType: String
    ## Default: emqx
    #app_name: emqx

    ## The suffix added to dns and hostname get from k8s service
    ##
    ## @doc cluster.k8s.suffix
    ## ValueType: String
    ## Default: "pod.local"
    #suffix: "pod.local"

    ## Kubernetes Namespace
    ##
    ## @doc cluster.k8s.namespace
    ## ValueType: String
    ## Default: default
    #namespace: default
  #}
}

##==================================================================
## Log
##==================================================================
log {
  ## The primary log level
  ##
  ## - all the log messages with levels lower than this level will
  ##   be dropped.
  ## - all the log messages with levels higher than this level will
  ##   go into the log handlers. The handlers then decide to log it
  ##   out or drop it according to the level setting of the handler.
  ##
  ## Note: Only the messages with severity level higher than or
  ## equal to this level will be logged.
  ##
  ## @doc log.level
  ## ValueType: debug | info | notice | warning | error | critical | alert | emergency
  ## Default: warning
  level: warning

  ##----------------------------------------------------------------
  ## console log handlers send log messages to emqx console
  ##----------------------------------------------------------------
  console_log_handlers: [
    {
      ## The log level of this handler
      ## All the log messages with levels lower than this level will
      ## be dropped.
      ##
      ## @doc log.console_log_handlers[].console.level
      ## ValueType: debug | info | notice | warning | error | critical | alert | emergency
      ## Default: warning
      level: warning
    }
  ]

  ##----------------------------------------------------------------
  ## file log handlers send log messages to files
  ##----------------------------------------------------------------
  file_log_handlers: [
    {
      ## The log level filter of this handler
      ## All the log messages with levels lower than this level will
      ## be dropped.
      ##
      ## @doc log.file_log_handlers[].level
      ## ValueType: debug | info | notice | warning | error | critical | alert | emergency
      ## Default: warning
      level: warning

      ## The log file for specified level.
      ##
      ## If `rotation` is disabled, this is the file of the log files.
      ##
      ## If `rotation` is enabled, this is the base name of the
      ## files. Each file in a rotated log is named <base_name>.N, where N is an integer.
      ##
      ## Note: Log files for a specific log level will only contain all the logs
      ##       that higher than or equal to that level
      ##
      ## @doc log.file_log_handlers[].file
      ## ValueType: File
      ## Required: true
      file: "{{ platform_log_dir }}/emqx.log"

      ## Enables the log rotation.
      ## With this enabled, new log files will be created when the current
      ## log file is full, max to `rotation.size` files will be created.
      ##
      ## @doc log.file_log_handlers[].rotation
      ## ValueType: Boolean
      ## Default: true
      #rotation: true

      ## Maximum size of each log file.
      ##
      ## @doc log.file_log_handlers[].rotation_size
      ## ValueType: Size
      ## Default: 10MB
      #rotation_size: 10MB

      ## Maximum rotation count of log files.
      ##
      ## @doc log.file_log_handlers[].rotation_count
      ## ValueType: Integer
      ## Range: [1, 2048]
      ## Default: 5
      #rotation_count: 5
    },

    ## You could also create multiple file handlers for different
    ## log level for example:
    #{
    #  type: file
    #  level: error
    #  file: "{{ platform_log_dir }}/emqx.error.log"
    #},
  ]

  ## Limits the total number of characters printed for each log event.
  ##
  ## @doc log.chars_limit
  ## ValueType: Integer | no_limit
  ## Default: no_limit
  #chars_limit: 8192

  ## Log formatter
  ## @doc log.formatter
  ## ValueType: text | json
  ## Default: text
  #formatter = text

  ## Log to single line
  ## @doc log.single_line
  ## ValueType: Boolean
  ## Default: true
  #single_line = true

  ## The max allowed queue length before switching to sync mode.
  ##
  ## Log overload protection parameter. If the message queue grows
  ## larger than this value the handler switches from anync to sync mode.
  ##
  ## @doc log.sync_mode_qlen
  ## ValueType: Integer
  ## Range: [0, ${log.drop_mode_qlen}]
  ## Default: 100
  #sync_mode_qlen: 100

  ## The max allowed queue length before switching to drop mode.
  ##
  ## Log overload protection parameter. When the message queue grows
  ## larger than this threshold, the handler switches to a mode in which
  ## it drops all new events that senders want to log.
  ##
  ## @doc log.drop_mode_qlen
  ## ValueType: Integer
  ## Range: [${log.sync_mode_qlen}, ${log.flush_qlen}]
  ## Default: 3000
  #drop_mode_qlen: 3000

  ## The max allowed queue length before switching to flush mode.
  ##
  ## Log overload protection parameter. If the length of the message queue
  ## grows larger than this threshold, a flush (delete) operation takes place.
  ## To flush events, the handler discards the messages in the message queue
  ## by receiving them in a loop without logging.
  ##
  ## @doc log.flush_qlen
  ## ValueType: Integer
  ## Range: [${log.drop_mode_qlen}, )
  ## Default: 8000
  #flush_qlen: 8000

  ## Kill the log handler when it gets overloaded.
  ##
  ## Log overload protection parameter. It is possible that a handler,
  ## even if it can successfully manage peaks of high load without crashing,
  ## can build up a large message queue, or use a large amount of memory.
  ## We could kill the log handler in these cases and restart it after a
  ## few seconds.
  ##
  ## @doc log.overload_kill
  ## ValueType: Boolean
  ## Default: true
  #overload_kill = true

  ## The max allowed queue length before killing the log hanlder.
  ##
  ## Log overload protection parameter. This is the maximum allowed queue
  ## length. If the message queue grows larger than this, the handler
  ## process is terminated.
  ##
  ## @doc log.overload_kill_qlen
  ## ValueType: Integer
  ## Range: [0, 1048576]
  ## Default: 20000
  #overload_kill_qlen: 20000

  ## The max allowed memory size before killing the log hanlder.
  ##
  ## Log overload protection parameter. This is the maximum memory size
  ## that the handler process is allowed to use. If the handler grows
  ## larger than this, the process is terminated.
  ##
  ## @doc log.overload_kill_mem_size
  ## ValueType: Size
  ## Default: 30MB
  #overload_kill_mem_size: 30MB

  ## Restart the log hanlder after some seconds.
  ##
  ## Log overload protection parameter. If the handler is terminated,
  ## it restarts automatically after a delay specified in seconds.
  ## The value "infinity" prevents restarts.
  ##
  ## @doc log.overload_kill_restart_after
  ## ValueType: Duration
  ## Default: 5s
  #overload_kill_restart_after: 5s

  ## Controlling Bursts of Log Requests.
  ##
  ## Log overload protection parameter. Large bursts of log events - many
  ## events received by the handler under a short period of time - can
  ## potentially cause problems. By specifying the maximum number of events
  ## to be handled within a certain time frame, the handler can avoid
  ## choking the log with massive amounts of printouts.
  ##
  ## Note that there would be no warning if any messages were
  ## dropped because of burst control.
  ##
  ## @doc log.burst_limit
  ## ValueType: Boolean
  ## Default: false
  #burst_limit = false

  ## This config controls the maximum number of events to handle within
  ## a time frame. After the limit is reached, successive events are
  ## dropped until the end of the time frame defined by `window_time`.
  ##
  ## @doc log.burst_limit_max_count
  ## ValueType: Integer
  ## Default: 10000
  #burst_limit_max_count: 10000

  ## See the previous description of burst_limit_max_count.
  ##
  ## @doc log.burst_limit_window_time
  ## ValueType: duration
  ## Default: 1s
  #burst_limit_window_time: 1s
}

##==================================================================
## RPC
##==================================================================
rpc {
  ## RPC Mode.
  ##
  ## @doc rpc.mode
  ## ValueType: sync | async
  ## Default: async
  mode: async

  ## Max batch size of async RPC requests.
  ##
  ## NOTE: RPC batch won't work when rpc.mode = sync
  ## Zero value disables rpc batching.
  ##
  ## @doc rpc.async_batch_size
  ## ValueType: Integer
  ## Range: [0, 1048576]
  ## Default: 0
  async_batch_size: 256

  ## RPC port discovery
  ##
  ## The strategy for discovering the RPC listening port of
  ## other nodes.
  ##
  ## @doc cluster.discovery_strategy
  ## ValueType: manual | stateless
  ##   - manual: discover ports by `tcp_server_port` and
  ##     `tcp_client_port`.
  ##   - stateless: discover ports in a stateless manner.
  ##     If node name is `emqx<N>@127.0.0.1`, where the `<N>` is
  ##     an integer, then the listening port will be `5370 + <N>`
  ##
  ## Default: `stateless`.
  port_discovery = stateless

  ## TCP server port for RPC.
  ##
  ## Only takes effect when `rpc.port_discovery` = `manual`.
  ##
  ## @doc rpc.tcp_server_port
  ## ValueType: Integer
  ## Range: [1024-65535]
  ## Defaults: 5369
  #tcp_server_port = 5369

  ## TCP port for outgoing RPC connections.
  ##
  ## Only takes effect when `rpc.port_discovery` = `manual`.
  ##
  ## @doc rpc.tcp_client_port
  ## ValueType: Integer
  ## Range: [1024-65535]
  ## Defaults: 5369
  #tcp_client_port = 5369

  ## Number of outgoing RPC connections.
  ##
  ## Defaults to "num_cpu_cores", that is, the number of CPU cores.
  ## Set this to 1 to keep the message order sent from the same
  ## client.
  ##
  ## @doc rpc.tcp_client_num
  ## ValueType: Integer | num_cpu_cores
  ## Range: [1, 256]
  ## Defaults: num_cpu_cores
  #tcp_client_num: 1

  ## RCP Client connect timeout.
  ##
  ## @doc rpc.connect_timeout
  ## ValueType: Duration
  ## Default: 5s
  #connect_timeout: 5s

  ## TCP send timeout of RPC client and server.
  ##
  ## @doc rpc.send_timeout
  ## ValueType: Duration
  ## Default: 5s
  #send_timeout: 5s

  ## Authentication timeout
  ##
  ## @doc rpc.authentication_timeout
  ## ValueType: Duration
  ## Default: 5s
  #authentication_timeout: 5s

  ## Default receive timeout for call() functions
  ##
  ## @doc rpc.call_receive_timeout
  ## ValueType: Duration
  ## Default: 15s
  #call_receive_timeout: 15s

  ## Socket idle keepalive.
  ##
  ## @doc rpc.socket_keepalive_idle
  ## ValueType: Duration
  ## Default: 900s
  #socket_keepalive_idle: 900s

  ## TCP Keepalive probes interval.
  ##
  ## @doc rpc.socket_keepalive_interval
  ## ValueType: Duration
  ## Default: 75s
  #socket_keepalive_interval: 75s

  ## Probes lost to close the connection
  ##
  ## @doc rpc.socket_keepalive_count
  ## ValueType: Integer
  ## Default: 9
  #socket_keepalive_count: 9

  ## Size of TCP send buffer.
  ##
  ## @doc rpc.socket_sndbuf
  ## ValueType: Size
  ## Default: 1MB
  socket_sndbuf = 1MB

  ## Size of TCP receive buffer.
  ##
  ## @doc rpc.socket_recbuf
  ## ValueType: Size
  ## Default: 1MB
  socket_recbuf = 1MB

  ## Size of user-level software socket buffer.
  ##
  ## @doc rpc.socket_buffer
  ## ValueType: Size
  ## Default: 1MB
  socket_buffer = 1MB
}

##==================================================================
## Broker
##==================================================================
broker {
  ## System interval of publishing $SYS messages.
  ##
  ## @doc broker.sys_msg_interval
  ## ValueType: Duration
  ## Default: 1m
  sys_msg_interval: 1m

  ## System heartbeat interval of publishing following heart beat message:
  ##  - "$SYS/brokers/<node>/uptime"
  ##  - "$SYS/brokers/<node>/datetime"
  ##
  ## @doc broker.sys_heartbeat_interval
  ## ValueType: Duration
  ## Default: 30s
  sys_heartbeat_interval: 30s

  ## Session locking strategy in a cluster.
  ##
  ## @doc broker.session_locking_strategy
  ## ValueType: local | one | quorum | all
  ##   - local: only lock the session locally on the current node
  ##   - one: select only one remove node to lock the session
  ##   - quorum: select some nodes to lock the session
  ##   - all: lock the session on all of the nodes in the cluster
  ## Default: quorum
  session_locking_strategy: quorum

  ## Dispatch strategy for shared subscription
  ##
  ## @doc broker.shared_subscription_strategy
  ## ValueType: random | round_robin | sticky | hash
  ##   - random: dispatch the message to a random selected subscriber
  ##   - round_robin: select the subscribers in a round-robin manner
  ##   - sticky: always use the last selected subscriber to dispatch,
  ##     until the susbcriber disconnected.
  ##   - hash: select the subscribers by the hash of clientIds
  ## Default: random
  shared_subscription_strategy: random

  ## Enable/disable shared dispatch acknowledgement for QoS1 and QoS2 messages
  ## This should allow messages to be dispatched to a different subscriber in
  ## the group in case the picked (based on shared_subscription_strategy) one # is offline
  ##
  ## @doc broker.shared_dispatch_ack_enabled
  ## ValueType: Boolean
  ## Default: false
  shared_dispatch_ack_enabled: false

  ## Enable batch clean for deleted routes.
  ##
  ## @doc broker.route_batch_clean
  ## ValueType: Boolean
  ## Default: false
  route_batch_clean: false

  ## Performance toggle for subscribe/unsubscribe wildcard topic.
  ## Change this toggle only when there are many wildcard topics.
  ##
  ## NOTE: when changing from/to 'global' lock, it requires all
  ## nodes in the cluster to be stopped before the change.
  ##
  ## @doc broker.perf.route_lock_type
  ## ValueType: key | tab | global
  ##  - key:   mnesia translational updates with per-key locks. recommended for single node setup.
  ##  - tab:   mnesia translational updates with table lock. recommended for multi-nodes setup.
  ##  - global: global lock protected updates. recommended for larger cluster.
  ## Default: key
  # perf.route_lock_type = key

  ## Enable trie path compaction.
  ## Enabling it significantly improves wildcard topic subscribe
  ## rate, if wildcard topics have unique prefixes like:
  ## 'sensor/{{id}}/+/', where ID is unique per subscriber.
  ##
  ## Topic match performance (when publishing) may degrade if messages
  ## are mostly published to topics with large number of levels.
  ##
  ## NOTE: This is a cluster-wide configuration.
  ## It rquires all nodes to be stopped before changing it.
  ##
  ## @doc broker.perf.trie_compaction
  ## ValueType: Boolean
  ## Default: true
  # perf.trie_compaction = true
}

## Enable authentication
##
## @doc auth.enable
## ValueType: Boolean
## Default: true
#auth.enable: true

## Enable per connection statistics.
##
## @doc stats.enable
## ValueType: Boolean
## Default: true
#stats.enable: true

##==================================================================
## MQTT Protocol
##==================================================================
mqtt {
  ## How long time the MQTT connection will be disconnected if the
  ## TCP connection is established but MQTT CONNECT has not been
  ## received.
  ##
  ## @doc mqtt.idle_timeout
  ## ValueType: Duration
  ## Default: 15s
  idle_timeout: 15s

  ## Maximum MQTT packet size allowed.
  ##
  ## @doc mqtt.max_packet_size
  ## ValueType: Bytes
  ## Default: 1MB
  max_packet_size: 1MB

  ## Maximum length of MQTT clientId allowed.
  ##
  ## @doc mqtt.max_clientid_len
  ## ValueType: Integer
  ## Range: [23, 65535]
  ## Default: 65535
  #max_clientid_len: 65535

  ## Maximum topic levels allowed.
  ##
  ## @doc mqtt.max_topic_levels
  ## ValueType: Integer | no_limit
  ## Range: [1, 65535]
  ## Default: no_limit
  #max_topic_levels: no_limit

  ## Maximum QoS allowed.
  ##
  ## @doc mqtt.max_qos_allowed
  ## ValueType: 0 | 1 | 2
  ## Default: 2
  #max_qos_allowed: 2

  ## Maximum Topic Alias, 0 means no topic alias supported.
  ##
  ## @doc mqtt.max_topic_alias
  ## ValueType: Integer
  ## Range: [0, 65535]
  ## Default: 65535
  #max_topic_alias: 65535

  ## Whether the Server supports MQTT retained messages.
  ##
  ## @doc mqtt.retain_available
  ## ValueType: Boolean
  ## Default: true
  #retain_available: true

  ## Whether the Server supports MQTT Wildcard Subscriptions
  ##
  ## @doc mqtt.wildcard_subscription
  ## ValueType: Boolean
  ## Default: true
  #wildcard_subscription: true

  ## Whether the Server supports MQTT Shared Subscriptions.
  ##
  ## @doc mqtt.shared_subscription
  ## ValueType: Boolean
  ## Default: true
  #shared_subscription: true

  ## Whether to ignore loop delivery of messages.(for mqtt v3.1.1)
  ##
  ## @doc mqtt.ignore_loop_deliver
  ## ValueType: Boolean
  ## Default: false
  #ignore_loop_deliver: false

  ## Whether to parse the MQTT frame in strict mode
  ##
  ## @doc mqtt.strict_mode
  ## ValueType: Boolean
  ## Default: false
  #strict_mode: false

  ## Specify the response information returned to the client
  ##
  ## This feature is disabled if not set
  ##
  ## @doc mqtt.response_information
  ## ValueType: String
  ## Default: null
  #response_information: null

  ## Server Keep Alive of MQTT 5.0
  ##
  ## @doc mqtt.server_keepalive
  ## ValueType: Number | disabled
  ## Default: disabled
  #server_keepalive: disabled

  ## The backoff for MQTT keepalive timeout. The broker will kick a connection out
  ## until 'Keepalive * backoff * 2' timeout.
  ##
  ## @doc mqtt.keepalive_backoff
  ## ValueType: Float
  ## Range: (0.5, 1]
  ## Default: 0.75
  #keepalive_backoff: 0.75

  ## Maximum number of subscriptions allowed, 0 means no limit.
  ##
  ## @doc mqtt.max_subscriptions
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: no_limit
  #max_subscriptions: no_limit

  ## Force to upgrade QoS according to subscription.
  ##
  ## @doc mqtt.upgrade_qos
  ## ValueType: Boolean
  ## Default: false
  #upgrade_qos: false

  ## Maximum size of the Inflight Window storing QoS1/2 messages delivered but unacked.
  ##
  ## @doc mqtt.max_inflight
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 32
  #max_inflight: 32

  ## Retry interval for QoS1/2 message delivering.
  ##
  ## @doc mqtt.retry_interval
  ## ValueType: Duration
  ## Default: 30s
  #retry_interval: 30s

  ## Maximum QoS2 packets (Client -> Broker) awaiting PUBREL, 0 means no limit.
  ##
  ## @doc mqtt.max_awaiting_rel
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 100
  #max_awaiting_rel: 100

  ## The QoS2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout.
  ##
  ## @doc mqtt.await_rel_timeout
  ## ValueType: Duration
  ## Default: 300s
  #await_rel_timeout: 300s

  ## Default session expiry interval for MQTT V3.1.1 connections.
  ##
  ## @doc mqtt.session_expiry_interval
  ## ValueType: Duration
  ## Default: 2h
  #session_expiry_interval: 2h

  ## Maximum queue length. Enqueued messages when persistent client disconnected,
  ## or inflight window is full. 0 means no limit.
  ##
  ## @doc mqtt.max_mqueue_len
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 1000
  #max_mqueue_len: 1000

  ## Topic priorities.
  ##
  ## There's no priority table by default, hence all messages
  ## are treated equal.
  ## The top topicname in the table has the highest priority, and then
  ## the next one has the second highest priority, etc.
  ## Messages for topics not in the priority table are treated as
  ## either highest or lowest priority depending on the configured
  ## value for mqtt.mqueue_default_priority
  ##
  ## @doc mqtt.mqueue_priorities
  ## ValueType: Array<TopicName>
  ## Example:
  ##  To configure "t/1" > "t/2" > "t/3":
  ##  mqueue_priorities: [t/1,t/2,t/3]
  ## Default: []
  #mqueue_priorities: []

  ## Default to highest priority for topics not matching priority table
  ##
  ## @doc mqtt.mqueue_default_priority
  ## ValueType: highest | lowest
  ## Default: highest
  #mqueue_default_priority: highest

  ## Whether to enqueue QoS0 messages.
  ##
  ## @doc mqtt.mqueue_store_qos0
  ## ValueType: Boolean
  ## Default: true
  #mqueue_store_qos0: true

  ## Prefix all topics with the mountpoint string.
  ##
  ## Variables in mountpoint path:
  ##  - %c: clientid
  ##  - %u: username
  ##
  ## @doc mqtt.mountpoint
  ## ValueType: String | none
  ## Default: none
  #mountpoint: none

  ## Whether use username replace client id
  ##
  ## @doc mqtt.use_username_as_clientid
  ## ValueType: Boolean
  ## Default: false
  #use_username_as_clientid: false

  ## Use the CN, DN or CRT field from the client certificate as a username.
  ## Only works for SSL connection.
  ##
  ## @doc mqtt.peer_cert_as_username
  ## ValueType: cn | dn | crt | disabled
  ## Default: disabled
  #peer_cert_as_username: disabled

}

acl {

  ## Enable ACL check.
  ##
  ## @doc acl.enable
  ## ValueType: Boolean
  ## Default: true
  enable: true

  ## Default ACL File.
  ##
  ## @doc acl.file
  ## ValueType: File
  ## Default: "{{ platform_etc_dir }}/acl.conf"
  file: "{{ platform_etc_dir }}/acl.conf"

  ## The action when acl check reject current operation
  ##
  ## @doc acl.deny_action
  ## ValueType: ignore | disconnect
  ## Default: ignore
  #deny_action: ignore

  ## Whether to enable ACL cache.
  ##
  ## If enabled, ACLs roles for each client will be cached in the memory
  ##
  ## @doc acl.cache.enable
  ## ValueType: Boolean
  ## Default: true
  cache.enable: true

  ## The maximum count of ACL entries can be cached for a client.
  ##
  ## @doc acl.cache.max_size
  ## ValueType: Integer
  ## Range: [0, 1048576]
  ## Default: 32
  #cache.max_size: 32

  ## The time after which an ACL cache entry will be deleted
  ##
  ## @doc acl.cache.ttl
  ## ValueType: Duration
  ## Default: 1m
  #cache.ttl: 1m
}

rate_limit {

  ## Maximum connections per second.
  ##
  ## @doc listeners.<name>.max_conn_rate
  ## ValueType: Number | no_limit
  ## Default: no_limit
  ## Example:
  ##   max_conn_rate: 1000
  #max_conn_rate: no_limit

  ## Message limit for the a external MQTT connection.
  ##
  ## @doc rate_limit.conn_messages_in
  ## ValueType: String
  ## Example: 100 messages per 10 seconds.
  ##   conn_messages_in: 100,10s
  #conn_messages_in = 100,10s

  ## Limit the rate of receiving packets for a MQTT connection.
  ## The rate is counted by bytes of packets per second.
  ##
  ## The connection won't accept more messages if the messages come
  ## faster than the limit.
  ##
  ## @doc rate_limit.conn_bytes_in
  ## ValueType: String
  ## Example: 100KB incoming per 10 seconds.
  ##   conn_bytes_in = 100KB,10s
  ##
  #conn_bytes_in: 100KB,10s

  ## Messages quota for the each of external MQTT connection.
  ## This value consumed by the number of recipient on a message.
  ##
  ## @doc rate_limit.quota.conn_messages_routing
  ## ValueType: String
  ## Example: 100 messaegs per 1s:
  ##   quota.conn_messages_routing: 100
  #quota.conn_messages_routing = 100,1s

  ## Messages quota for the all of external MQTT connections.
  ## This value consumed by the number of recipient on a message.
  ##
  ## @doc rate_limit.quota.overall_messages_routing
  ## ValueType: String
  ## Range: (0, )
  ## Example: 200000 messages per 1s:
  ##    quota.overall_messages_routing: 200000
  ##
  #quota.overall_messages_routing = 200000,1s

}

flapping_detect {
  ## Enable Flapping Detection.
  ##
  ## This config controls the allowed maximum number of CONNECT received
  ## from the same clientid in a time frame defined by `window_time`.
  ## After the limit is reached, successive CONNECT requests are forbidden
  ## (banned) until the end of the time period defined by `ban_time`.
  ##
  ## @doc flapping_detect.enable
  ## ValueType: Boolean
  ## Default: true
  enable: true

  policy {
    ## The max disconnect allowed of a MQTT Client in `window_time`
    ##
    ## @doc flapping_detect.max_count
    ## ValueType: Integer
    ## Default: 30
    max_count: 30

    ## The time window for flapping detect
    ##
    ## @doc flapping_detect.window_time
    ## ValueType: Duration
    ## Default: 1m
    window_time: 1m

    ## How long the clientid will be banned
    ##
    ## @doc flapping_detect.ban_time
    ## ValueType: Duration
    ## Default: 5m
    ban_time: 5m
  }

}

force_shutdown: {
  ## Enable force_shutdown_policy
  ##
  ## @doc force_shutdown.enable
  ## ValueType: Boolean
  ## Default: true
  enable: true

  ## Max message queue length
  ## @doc force_shutdown.policy.max_message_queue_len
  ## ValueType: Integer
  ## Range: (0, )
  ## Default: system-architecture
  ##   - arch_64: 10000
  ##   - arch_32: 1000
  #policy.max_message_queue_len: 1000

  ## Total heap size
  ##
  ## @doc force_shutdown.policy.max_heap_size
  ## ValueType: Size
  ## Default: system-architecture
  ##   - arch_64: 64MB
  ##   - arch_32: 32MB
  #policy.max_heap_size: 32MB
}

conn_congestion: {
  ## Whether to alarm the congested connections.
  ##
  ## Sometimes the mqtt connection (usually an MQTT subscriber) may
  ## get "congested" because there're too many packets to sent.
  ## The socket trys to buffer the packets until the buffer is
  ## full. If more packets comes after that, the packets will be
  ## "pending" in a queue and we consider the connection is
  ## "congested".
  ##
  ## Enable this to send an alarm when there's any bytes pending in
  ## the queue. You could set the `listener.tcp.<ZoneName>.sndbuf`
  ## to a larger value if the alarm is triggered too often.
  ##
  ## The name of the alarm is of format "conn_congestion/<ClientID>/<Username>".
  ## Where the <ClientID> is the client-id of the congested MQTT connection.
  ## And the <Username> is the username or "unknown_user" of not provided by the client.
  ##
  ## @doc conn_congestion.alarm.enable
  ## ValueType: Boolean
  ## Default: true
  #conn_congestion.alarm.enable = true

  ## Won't clear the congested alarm in how long time.
  ## The alarm is cleared only when there're no pending bytes in
  ## the queue, and also it has been `alarm.min_sustain_duration`
  ## time since the last time we considered the connection is "congested".
  ##
  ## This is to avoid clearing and sending the alarm again too often.
  ##
  ## @doc conn_congestion.alarm.min_sustain_duration
  ## ValueType: Duration
  ## Default: 1m
  #conn_congestion.alarm.min_sustain_duration = 1m
}

##==================================================================
## Zones and Listeners
##==================================================================
## A zone contains a set of configurations for listeners.
##
## The configurations defined in zone can be overridden by the ones
## defined in listeners with the same key.
##
## For example given the following config:
## ```
## a: {b:0, c: 0}
##
## zone.x {
##   a: {b:1, c: 1}
##   listeners.y {
##     a: {b: 2}
##   }
## }
## ```
## The config "a" outside the zone "x" works like a global config
## and will be overridden by the configs inside the zone. And then
## it is overridden again by the configs inside the listener "y".
## So the value of config "a" in listener "y" is `a: {b:2, c: 1}`.
##
## All the "global" configs that can be overridden in zones and
## listeners are:
##   - `auth.*`
##   - `stats.*`
##   - `mqtt.*`
##   - `acl.*`
##   - `rate_limit.*`
##   - `flapping_detect.*`
##   - `force_shutdown.*`
##   - `conn_congestion.*`
##
## And all the `listener.*` configs can be put into zones.
##
## Syntax: zone.<zone-name> {}
zone.external {
  mqtt.max_packet_size: 64KB
  mqtt.idle_timeout: 15s
  max_connections: 1024000

  listeners.mqtt {

    ## The type of the listener.
    ##
    ## @doc listeners.<name>.type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: tcp

    ## The IP address and port that the listener will bind.
    ##
    ## @doc listeners.<name>.bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 1883, 127.0.0.1:1883, ::1:1883
    bind: "0.0.0.0:1883"

    ## The size of the acceptor pool for this listener.
    ##
    ## @doc listeners.<name>.acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum number of concurrent connections.
    ##
    ## @doc listeners.<name>.max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @doc listeners.<name>.access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @doc listeners.<name>.active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @doc listeners.<name>.proxy_protocol
    ## ValueType: Boolean
    ## Default: false
    #proxy_protocol: false

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @doc listeners.<name>.proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## TCP Options
    tcp_options: ${refs.tcp_opts} {
      backlog: 1024
    }
  }

  ## MQTT/SSL - SSL Listener for MQTT Protocol
  listeners.mqtt-ssl {

    ## The type of the listener.
    ##
    ## @doc listeners.<name>.type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: ssl

    ## The IP address and port that the listener will bind.
    ##
    ## @doc listeners.<name>.bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8883, 127.0.0.1:8883, ::1:8883
    bind: "0.0.0.0:8883"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @doc listeners.<name>.zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The size of the acceptor pool for this listener.
    ##
    ## @doc listeners.<name>.acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @doc listeners.<name>.max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @doc listeners.<name>.max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 512000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @doc listeners.<name>.access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @doc listeners.<name>.active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @doc listeners.<name>.proxy_protocol
    ## ValueType: Boolean
    ## Default: true
    #proxy_protocol: true

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @doc listeners.<name>.proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## SSL Options
    ssl_options: ${refs.ssl_opts} {
      keyfile: "{{ platform_etc_dir }}/certs/key.pem"
      certfile: "{{ platform_etc_dir }}/certs/cert.pem"
      cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"
    }

    ## TCP Options
    tcp_options: ${refs.tcp_opts} {
      backlog: 1024
    }
  }

  listeners.mqtt-ws {

    ## The type of the listener.
    ##
    ## @doc listeners.<name>.type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: ws

    ## The IP address and port that the listener will bind.
    ##
    ## @doc listeners.<name>.bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8083, 127.0.0.1:8083, ::1:8083
    bind: "0.0.0.0:8083"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @doc listeners.<name>.zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The path of WebSocket MQTT endpoint
    ##
    ## @doc listeners.<name>.mqtt_path
    ## ValueType: Path
    ## Default: "/mqtt"
    mqtt_path: /mqtt

    ## The size of the acceptor pool for this listener.
    ##
    ## @doc listeners.<name>.acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @doc listeners.<name>.max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @doc listeners.<name>.max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @doc listeners.<name>.access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @doc listeners.<name>.active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @doc listeners.<name>.proxy_protocol
    ## ValueType: Boolean
    ## Default: true
    #proxy_protocol: true

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @doc listeners.<name>.proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## Whether a WebSocket message is allowed to contain multiple MQTT packets
    ##
    ## @doc listeners.<name>.mqtt_piggyback
    ## ValueType: single | multiple
    ## Default: multiple
    #mqtt_piggyback: multiple

    ## TCP Options
    tcp_options: ${refs.tcp_opts} {
      backlog: 1024
    }

    ## Websocket Options
    websocket_options: ${refs.websocket_opts}
  }

  listeners.mqtt-wss {
    ## The name of the listener.
    ##
    ## @doc listeners.<name>.name
    ## ValueType: String
    ## Required: true
    name: mqtt_over_wss

    ## The type of the listener.
    ##
    ## @doc listeners.<name>.type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: wss

    ## The IP address and port that the listener will bind.
    ##
    ## @doc listeners.<name>.bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8084, 127.0.0.1:8084, ::1:8084
    bind: "0.0.0.0:8084"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @doc listeners.<name>.zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The path of WebSocket MQTT endpoint
    ##
    ## @doc listeners.<name>.mqtt_path
    ## ValueType: Path
    ## Default: "/mqtt"
    mqtt_path: /mqtt

    ## The size of the acceptor pool for this listener.
    ##
    ## @doc listeners.<name>.acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @doc listeners.<name>.max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @doc listeners.<name>.max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 512000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @doc listeners.<name>.access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @doc listeners.<name>.active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @doc listeners.<name>.proxy_protocol
    ## ValueType: Boolean
    ## Default: true
    #proxy_protocol: true

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @doc listeners.<name>.proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## Whether a WebSocket message is allowed to contain multiple MQTT packets
    ##
    ## @doc listeners.<name>.mqtt_piggyback
    ## ValueType: single | multiple
    ## Default: multiple
    #mqtt_piggyback: multiple

    ## SSL Options
    ssl_options: ${refs.ssl_opts} {
      keyfile: "{{ platform_etc_dir }}/certs/key.pem"
      certfile: "{{ platform_etc_dir }}/certs/cert.pem"
      cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"
    }

    ## TCP Options
    tcp_options: ${refs.tcp_opts} {
      backlog: 1024
    }

    ## Websocket Options
    websocket_options: ${refs.websocket_opts}
  }

}

#This is an example zone which has less "strict" settings.
#It's useful to clients connecting the broker from trusted networks.
zone.internal {
  acl.enable: false
  auth.enable: false
  rate_limit.max_conn_rate: 1000

  listeners.mqtt-internal {
    type: tcp
    bind: "127.0.0.1:11883"
    acceptors: 4
    max_connections: 1024000
    active_n: 1000
    tcp_options: ${refs.tcp_opts} {
      backlog: 512
    }
  }
}

##==================================================================
## System Monitor
##==================================================================
#sysmon {
  ## The time interval for the periodic process limit check
  ##
  ## @doc sysmon.vm.process_check_interval
  ## ValueType: Duration
  ## Default: 30s
  #vm.process_check_interval: 30s

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is set.
  ##
  ## @doc sysmon.vm.process_high_watermark
  ## ValueType: Percentage
  ## Default: 80%
  #vm.process_high_watermark: 80%

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is clear.
  ##
  ## @doc sysmon.vm.process_low_watermark
  ## ValueType: Percentage
  ## Default: 60%
  #vm.process_low_watermark: 60%

  ## Enable Long GC monitoring.
  ## Notice: don't enable the monitor in production for:
  ## https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421
  ##
  ## @doc sysmon.vm.long_gc
  ## ValueType: Duration | disabled
  ## Default: disabled
  #vm.long_gc: disabled

  ## Enable Long Schedule(ms) monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @doc sysmon.vm.long_schedule
  ## ValueType: Duration | disabled
  ## Default: disabled
  #vm.long_schedule: 240ms

  ## Enable Large Heap monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @doc sysmon.vm.large_heap
  ## ValueType: Size | disabled
  ## Default: Depends on system-architecture
  ##   - arch_64: 32MB
  ##   - arch_32: 64MB
  #vm.large_heap: 32MB

  ## Enable Busy Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @doc sysmon.vm.busy_port
  ## ValueType: Boolean
  ## Default: true
  #vm.busy_port: true

  ## Enable Busy Dist Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @doc sysmon.vm.busy_dist_port
  ## ValueType: Boolean
  ## Default: true
  #vm.busy_dist_port: true

  ## The time interval for the periodic cpu check
  ##
  ## @doc sysmon.os.cpu_check_interval
  ## ValueType: Duration
  ## Default: 60s
  #os.cpu_check_interval: 60s

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is set.
  ##
  ## @doc sysmon.os.cpu_high_watermark
  ## ValueType: Percentage
  ## Default: 80%
  #os.cpu_high_watermark: 80%

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is clear.
  ##
  ## @doc sysmon.os.cpu_low_watermark
  ## ValueType: Percentage
  ## Default: 60%
  #os.cpu_low_watermark: 60%

  ## The time interval for the periodic memory check
  ##
  ## @doc sysmon.os.mem_check_interval
  ## ValueType: Duration | disabled
  ## Default: 60s
  #os.mem_check_interval: 60s

  ## The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set.
  ##
  ## @doc sysmon.os.sysmem_high_watermark
  ## ValueType: Percentage
  ## Default: 70%
  #os.sysmem_high_watermark: 70%

  ## The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set.
  ##
  ## @doc sysmon.os.procmem_high_watermark
  ## ValueType: Percentage
  ## Default: 5%
  #os.procmem_high_watermark: 5%
#}

##==================================================================
## Alarm
##==================================================================
#alarm {
  ## Specifies the actions to take when an alarm is activated
  ##
  ## @doc alarm.actions
  ## ValueType: Array<AlarmAction>
  ## Default: [log, publish]
  #actions: [log, publish]

  ## The maximum number of deactivated alarms
  ##
  ## @doc alarm.size_limit
  ## ValueType: Integer
  ## Default: 1000
  #size_limit: 1000

  ## Validity Period of deactivated alarms
  ##
  ## @doc alarm.validity_period
  ## ValueType: Duration
  ## Default: 24h
  #validity_period: 24h
#}

## Config references for listeners
refs {
  ## Socket options for TCP connections
  ## See: http://erlang.org/doc/man/inet.html
  tcp_opts {
    ## TCP backlog defines the maximum length that the queue of
    ## pending connections can grow to.
    ##
    ## @doc listeners.<name>.tcp_options.backlog
    ## ValueType: Number
    ## Range: [0, 1048576]
    ## Default: 128
    #backlog: 1024

    ## The TCP send timeout for the connections.
    ##
    ## @doc listeners.<name>.tcp_options.send_timeout
    ## ValueType: Duration
    ## Default: 15s
    send_timeout: 15s

    ## Close the connection if send timeout.
    ##
    ## @doc listeners.<name>.tcp_options.send_timeout_close
    ## ValueType: Boolean
    ## Default: true
    #send_timeout_close: true

    ## The TCP receive buffer(os kernel) for the connections.
    ##
    ## @doc listeners.<name>.tcp_options.recbuf
    ## ValueType: Size
    ## Default: 4KB
    recbuf: 4KB

    ## The TCP send buffer(os kernel) for the connections.
    ##
    ## @doc listeners.<name>.tcp_options.sndbuf
    ## ValueType: Size
    ## Default: 4KB
    sndbuf: 4KB

    ## The size of the user-level software buffer used by the driver.
    ##
    ## @doc listeners.<name>.tcp_options.buffer
    ## ValueType: Size
    ## Default: 4KB
    buffer: 4KB

    ## Sets the 'buffer: max(sndbuf, recbuf)' if this option is enabled.
    ##
    ## @doc listeners.<name>.tcp_options.tune_buffer
    ## ValueType: Boolean
    ## Default: false
    #tune_buffer: false

    ## The TCP_NODELAY flag for the connections.
    ##
    ## @doc listeners.<name>.tcp_options.nodelay
    ## ValueType: Boolean
    ## Default: true
    #nodelay: true

    ## The SO_REUSEADDR flag for the connections.
    ##
    ## @doc listeners.<name>.tcp_options.reuseaddr
    ## ValueType: Boolean
    ## Default: true
    #reuseaddr: true
  }

  ## Socket options for SSL connections
  ## See: http://erlang.org/doc/man/ssl.html
  ssl_opts {
    ## A performance optimization setting, it allows clients to reuse
    ## pre-existing sessions, instead of initializing new ones.
    ## Read more about it here.
    ##
    ## @doc listeners.<name>.ssl_options.reuse_sessions
    ## ValueType: Boolean
    ## Default: true
    reuse_sessions: true

    ## SSL parameter renegotiation is a feature that allows a client and a server
    ## to renegotiate the parameters of the SSL connection on the fly.
    ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
    ## you drop support for the insecure renegotiation, prone to MitM attacks.
    ##
    ## @doc listeners.<name>.ssl_options.secure_renegotiate
    ## ValueType: Boolean
    ## Default: false
    #secure_renegotiate: false

    ## An important security setting, it forces the cipher to be set based
    ## on the server-specified order instead of the client-specified order,
    ## hence enforcing the (usually more properly configured) security
    ## ordering of the server administrator.
    ##
    ## @doc listeners.<name>.ssl_options.honor_cipher_order
    ## ValueType: Boolean
    ## Default: true
    #honor_cipher_order: true

    ## TLS versions only to protect from POODLE attack.
    ##
    ## @doc listeners.<name>.ssl_options.tls_versions
    ## ValueType: Array<TLSVersion>
    ## Default: [tlsv1.2,tlsv1.1,tlsv1]
    #tls_versions: [tlsv1.2,tlsv1.1,tlsv1]

    ## TLS Handshake timeout.
    ##
    ## @doc listeners.<name>.ssl_options.handshake_timeout
    ## ValueType: Duration
    ## Default: 15s
    handshake_timeout: 15s

    ## Path to the file containing the user's private PEM-encoded key.
    ##
    ## @doc listeners.<name>.ssl_options.keyfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/key.pem"
    keyfile: "{{ platform_etc_dir }}/certs/key.pem"

    ## Path to a file containing the user certificate.
    ##
    ## @doc listeners.<name>.ssl_options.certfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cert.pem"
    certfile: "{{ platform_etc_dir }}/certs/cert.pem"

    ## Path to the file containing PEM-encoded CA certificates. The CA certificates
    ## are used during server authentication and when building the client certificate chain.
    ##
    ## @doc listeners.<name>.ssl_options.cacertfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cacert.pem"
    cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"

    ## The Ephemeral Diffie-Helman key exchange is a very effective way of
    ## ensuring Forward Secrecy by exchanging a set of keys that never hit
    ## the wire. Since the DH key is effectively signed by the private key,
    ## it needs to be at least as strong as the private key. In addition,
    ## the default DH groups that most of the OpenSSL installations have
    ## are only a handful (since they are distributed with the OpenSSL
    ## package that has been built for the operating system it’s running on)
    ## and hence predictable (not to mention, 1024 bits only).
    ## In order to escape this situation, first we need to generate a fresh,
    ## strong DH group, store it in a file and then use the option above,
    ## to force our SSL application to use the new DH group. Fortunately,
    ## OpenSSL provides us with a tool to do that. Simply run:
    ## openssl dhparam -out dh-params.pem 2048
    ##
    ## @doc listeners.<name>.ssl_options.dhfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/dh-params.pem"
    #dhfile: "{{ platform_etc_dir }}/certs/dh-params.pem"

    ## A server only does x509-path validation in mode verify_peer,
    ## as it then sends a certificate request to the client (this
    ## message is not sent if the verify option is verify_none).
    ## You can then also want to specify option fail_if_no_peer_cert.
    ## More information at: http://erlang.org/doc/man/ssl.html
    ##
    ## @doc listeners.<name>.ssl_options.verify
    ## ValueType: verify_peer | verify_none
    ## Default: verify_none
    #verify: verify_peer

    ## Used together with {verify, verify_peer} by an SSL server. If set to true,
    ## the server fails if the client does not have a certificate to send, that is,
    ## sends an empty certificate.
    ##
    ## @doc listeners.<name>.ssl_options.fail_if_no_peer_cert
    ## ValueType: Boolean
    ## Default: true
    #fail_if_no_peer_cert: true

    ## This is the single most important configuration option of an Erlang SSL
    ## application. Ciphers (and their ordering) define the way the client and
    ## server encrypt information over the wire, from the initial Diffie-Helman
    ## key exchange, the session key encryption ## algorithm and the message
    ## digest algorithm. Selecting a good cipher suite is critical for the
    ## application’s data security, confidentiality and performance.
    ##
    ## The cipher list above offers:
    ##
    ## A good balance between compatibility with older browsers.
    ## It can get stricter for Machine-To-Machine scenarios.
    ## Perfect Forward Secrecy.
    ## No old/insecure encryption and HMAC algorithms
    ##
    ## Most of it was copied from Mozilla’s Server Side TLS article
    ##
    ## @doc listeners.<name>.ssl_options.ciphers
    ## ValueType: Array<Cipher>
    ## Default: [ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA]
    #ciphers: []

    ## Ciphers for TLS PSK. See 'https://tools.ietf.org/html/rfc4279#section-2'.
    ##
    ## Note that 'ciphers' and 'psk_ciphers' cannot be configured at the same time.
    ##
    ## @doc listeners.<name>.ssl_options.psk_ciphers
    ## ValueType: Array<Cipher>
    ## Default: [PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA]
    #psk_ciphers: []
  }

  ## Socket options for websocket connections
  websocket_opts {
    ## The compress flag for external WebSocket connections.
    ##
    ## If this Value is set true,the websocket message would be compressed
    ##
    ## @doc listeners.<name>.websocket_options.compress
    ## ValueType: Boolean
    ## Default: true
    #compress: true

    ## The idle timeout for external WebSocket connections.
    ##
    ## @doc listeners.<name>.websocket_options.idle_timeout
    ## ValueType: Duration | infinity
    ## Default: infinity
    idle_timeout: infinity

    ## The max frame size for external WebSocket connections.
    ##
    ## @doc listeners.<name>.websocket_options.max_frame_size
    ## ValueType: Size
    ## Default: no_limit
    max_frame_size: no_limit

    deflate_opts {
      ## The level of deflate options for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.level
      ## ValueType: none | default | best_compression | best_speed
      ## Default: default
      #level: default

      ## The mem_level of deflate options for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.mem_level
      ## ValueType: Integer
      ## Range: [1,9]
      ## Default: 8
      #mem_level: 8

      ## The strategy of deflate options for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.strategy
      ## ValueType: default | filtered | huffman_only | rle
      ## Default: default
      #strategy: default

      ## The deflate option for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.server_context_takeover
      ## ValueType: takeover | no_takeover
      ## Default: takeover
      #server_context_takeover: takeover

      ## The deflate option for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.client_context_takeover
      ## ValueType: takeover | no_takeover
      ## Default: takeover
      #client_context_takeover: takeover

      ## The deflate options for external WebSocket connections.
      ##
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.server_max_window_bits
      ## ValueType: Integer
      ## Range: [8,15]
      ## Default: 15
      #server_max_window_bits: 15

      ## The deflate options for external WebSocket connections.
      ##
      ## @doc listeners.<name>.websocket_options.deflate_opts.client_max_window_bits
      ## ValueType: Integer
      ## Range: [8,15]
      ## Default: 15
      #client_max_window_bits: 15
    }
  }
}