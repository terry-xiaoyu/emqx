##====================================================================
## Node
##====================================================================
node {
  ## Node name.
  ## See: http://erlang.org/doc/reference_manual/distributed.html
  ##
  ## @spec node.name
  ## ValueType: NodeName
  ## Default: emqx@127.0.0.1
  name: "emqx@127.0.0.1"

  ## Cookie for distributed node communication.
  ##
  ## @spec node.cookie
  ## ValueType: String
  ## Default: emqxsecretcookie
  cookie: emqxsecretcookie

  ## Data dir for the node
  ##
  ## @spec node.data_dir
  ## ValueType: Folder
  ## Default: "{{ platform_data_dir }}/"
  data_dir: "{{ platform_data_dir }}/"

  ## Dir of crash dump file.
  ##
  ## @spec node.crash_dump_dir
  ## ValueType: Folder
  ## Default: "{{ platform_log_dir }}/"
  #crash_dump_dir: "{{ platform_log_dir }}/"

  ## Global GC Interval.
  ##
  ## @spec node.global_gc_interval
  ## ValueType: Duration
  ## Default: 15m
  #global_gc_interval: 15m
}

##====================================================================
## Cluster
##====================================================================
cluster {
  ## Cluster name.
  ##
  ## @spec cluster.name
  ## ValueType: String
  ## Default: emqxcl
  name: emqxcl

  ## Enable cluster autoheal from network partition.
  ##
  ## @spec cluster.autoheal
  ## ValueType: Flag
  ## Default: on
  autoheal: on

  ## Autoclean down node. A down node will be removed from the cluster
  ## if this value > 0.
  ##
  ## @spec cluster.autoclean
  ## ValueType: Duration
  ## Default: 5m
  autoclean: 5m

  ## Node discovery strategy to join the cluster.
  ##
  ## @spec cluster.discovery_strategy
  ## ValueType: manual | static | mcast | dns | etcd | k8s
  ##   - manual: Manual join command
  ##   - static: Static node list
  ##   - mcast:  IP Multicast
  ##   - dns:    DNS A Record
  ##   - etcd:   etcd
  ##   - k8s:    Kubernetes
  ##
  ## Default: manual
  discovery_strategy: manual

  ##------------------------------------------------------------------
  ## Cluster using static node list
  ##------------------------------------------------------------------
  #static {
    ## Node list of the cluster
    ##
    ## @spec cluster.static.seeds
    ## ValueType: Array<NodeName>
    ## Default: ["emqx1@127.0.0.1", "emqx2@127.0.0.1"]
    #seeds: ["emqx1@127.0.0.1", "emqx2@127.0.0.1"]
  #}

  ##------------------------------------------------------------------
  ## Cluster using IP Multicast
  ##------------------------------------------------------------------
  #mcast {
    ## IP Multicast Address.
    ##
    ## @spec cluster.mcast.addr
    ## ValueType: IPAddress
    ## Default: 239.192.0.1
    #addr: 239.192.0.1

    ## Multicast Ports.
    ##
    ## @spec cluster.mcast.ports
    ## ValueType: Array<Port>
    ## Default: [4369, 4370]
    #ports: [4369, 4370]

    ## Multicast Iface.
    ##
    ## @spec cluster.mcast.iface
    ## ValueType: IPAddress
    ## Default: 0.0.0.0
    #iface: 0.0.0.0

    ## Multicast Ttl.
    ##
    ## @spec cluster.mcast.ttl
    ## ValueType: Integer
    ## Range: [0,255]
    ## Default: 255
    #ttl: 255

    ## Multicast loop.
    ##
    ## @spec cluster.mcast.loop
    ## ValueType: Flag
    ## Default: on
    #loop: on
  #}

  ##------------------------------------------------------------------
  ## Cluster using DNS A records
  ##------------------------------------------------------------------
  #dns {
    ## DNS name.
    ##
    ## @spec cluster.dns.name
    ## ValueType: String
    ## Default: localhost
    #name: localhost

    ## The App name is used to build 'node.name' with IP address.
    ##
    ## @spec cluster.dns.app
    ## ValueType: String
    ## Default: emqx
    #app: emqx
  #}

  ##------------------------------------------------------------------
  ## Cluster using etcd
  ##------------------------------------------------------------------
  #etcd {
    ## Etcd server list, seperated by ','.
    ##
    ## @spec cluster.etcd.server
    ## ValueType: URL
    ## Required: true
    #server: http://127.0.0.1:2379

    ## The prefix helps build nodes path in etcd. Each node in the cluster
    ## will create a path in etcd: v2/keys/<prefix>/<name>/<node.name>
    ##
    ## @spec cluster.etcd.prefix
    ## ValueType: String
    ## Default: emqxcl
    #prefix: emqxcl

    ## The TTL for node's path in etcd.
    ##
    ## @spec cluster.etcd.node_ttl
    ## ValueType: Duration
    ## Default: 1m
    #node_ttl: 1m

    ## SSL Options
    ## @spec cluster.etcd.ssl_options
    ## ValueType: ${socket.ssl_options}
    ## Default: ${socket.ssl_options}
    #ssl_options: ${socket.ssl_options} {
      #keyfile: "{{ platform_etc_dir }}/certs/client-key.pem"
      #certfile: "{{ platform_etc_dir }}/certs/client.pem"
      #cacertfile: "{{ platform_etc_dir }}/certs/ca.pem"
    #}
  #}

  ##------------------------------------------------------------------
  ## Cluster using Kubernetes
  ##------------------------------------------------------------------
  #k8s {
    ## Kubernetes API server list, seperated by ','.
    ##
    ## @spec cluster.k8s.apiserver
    ## ValueType: URL
    ## Required: true
    #apiserver: "http://10.110.111.204:8080"

    ## The service name helps lookup EMQ nodes in the cluster.
    ##
    ## @spec cluster.k8s.service_name
    ## ValueType: String
    ## Default: emqx
    #service_name: emqx

    ## The address type is used to extract host from k8s service.
    ##
    ## @spec cluster.k8s.address_type
    ## ValueType: ip | dns | hostname
    ## Default: ip
    #address_type: ip

    ## The app name helps build 'node.name'.
    ##
    ## @spec cluster.k8s.app_name
    ## ValueType: String
    ## Default: emqx
    #app_name: emqx

    ## The suffix added to dns and hostname get from k8s service
    ##
    ## @spec cluster.k8s.suffix
    ## ValueType: String
    ## Default: "pod.local"
    #suffix: "pod.local"

    ## Kubernetes Namespace
    ##
    ## @spec cluster.k8s.namespace
    ## ValueType: String
    ## Default: default
    #namespace: default
  #}
}

##====================================================================
## Log
##====================================================================
log {
  ## This is the global log level:
  ##
  ## - all the log messages with levels lower than this level will be
  ##   dropped.
  ## - all the log messages with levels higher than this level will go
  ##   into the log handlers. The handlers then decide to log it out or
  ##   drop it according to the level setting of the handler.
  ##
  ## Note: Only the messages with severity level higher than or equal to
  ##       this level will be logged.
  ##
  ## @spec log.level
  ## ValueType: debug | info | notice | warning | error | critical | alert | emergency
  ## Default: warning
  level: warning

  handlers: [
    ##----------------------------------------------------------------
    ## console log handlers send log messages to emqx console
    ##----------------------------------------------------------------
    #{
      #type: console

      ## The log level of this handler
      ## All the log messages with levels lower than this level will
      ## be dropped.
      ##
      ## @spec log.handlers.console.level
      ## ValueType: all | debug | info | notice | warning | error | critical | alert | emergency
      ## Default: all
      #level: all
    #},

    ##----------------------------------------------------------------
    ## file log handlers send log messages to files
    ##----------------------------------------------------------------
    {
      type: file

      ## The log level filter of this handler
      ## All the log messages with levels lower than this level will
      ## be dropped.
      ##
      ## @spec log.handlers.file[].level
      ## ValueType: all | debug | info | notice | warning | error | critical | alert | emergency
      ## Default: all
      level: all

      ## The log filename for specified level.
      ##
      ## If `rotation` is disabled, this is the filename of the log files.
      ##
      ## If `rotation` is enabled, this is the base name of the
      ## files. Each file in a rotated log is named <base_name>.N, where N is an integer.
      ##
      ## Note: Log files for a specific log level will only contain all the logs
      ##       that higher than or equal to that level
      ##
      ## @spec log.handlers.file[].filename
      ## ValueType: File
      ## Required: true
      filename: "{{ platform_log_dir }}/emqx.log"

      ## Enables the log rotation.
      ## With this enabled, new log files will be created when the current
      ## log file is full, max to `rotation.size` files will be created.
      ##
      ## @spec log.handlers.file[].rotation
      ## ValueType: Flag
      ## Default: on
      #rotation: on

      ## Maximum size of each log file.
      ##
      ## @spec log.handlers.file[].rotation_size
      ## ValueType: Size
      ## Default: 10MB
      #rotation_size: 10MB

      ## Maximum rotation count of log files.
      ##
      ## @spec log.handlers.file[].rotation_count
      ## ValueType: Integer
      ## Range: [1, 2048]
      ## Default: 5
      #rotation_count: 5
    },

    #{
    #  type: file
    #  level: error
    #  filename: "{{ platform_log_dir }}/emqx.error.log"
    #},
  ]

  ## Limits the total number of characters printed for each log event.
  ##
  ## @spec log.chars_limit
  ## ValueType: Integer | no_limit
  ## Default: no_limit
  #chars_limit: 8192

  ## The max allowed queue length before switching to sync mode.
  ##
  ## Log overload protection parameter. If the message queue grows
  ## larger than this value the handler switches from anync to sync mode.
  ##
  ## @spec log.sync_mode_qlen
  ## ValueType: Integer
  ## Range: [0, ${log.drop_mode_qlen}]
  ## Default: 100
  #sync_mode_qlen: 100

  ## The max allowed queue length before switching to drop mode.
  ##
  ## Log overload protection parameter. When the message queue grows
  ## larger than this threshold, the handler switches to a mode in which
  ## it drops all new events that senders want to log.
  ##
  ## @spec log.drop_mode_qlen
  ## ValueType: Integer
  ## Range: [${log.sync_mode_qlen}, ${log.flush_qlen}]
  ## Default: 3000
  #drop_mode_qlen: 3000

  ## The max allowed queue length before switching to flush mode.
  ##
  ## Log overload protection parameter. If the length of the message queue
  ## grows larger than this threshold, a flush (delete) operation takes place.
  ## To flush events, the handler discards the messages in the message queue
  ## by receiving them in a loop without logging.
  ##
  ## @spec log.flush_qlen
  ## ValueType: Integer
  ## Range: [${log.drop_mode_qlen}, )
  ## Default: 8000
  #flush_qlen: 8000

  ## Kill the log handler when it gets overloaded.
  ##
  ## Log overload protection parameter. It is possible that a handler,
  ## even if it can successfully manage peaks of high load without crashing,
  ## can build up a large message queue, or use a large amount of memory.
  ## We could kill the log handler in these cases and restart it after a
  ## few seconds.
  ##
  ## @spec log.overload_kill
  ## ValueType: Object | disabled
  ## Default: disabled
  #overload_kill_policy {
    ## The max allowed queue length before killing the log hanlder.
    ##
    ## Log overload protection parameter. This is the maximum allowed queue
    ## length. If the message queue grows larger than this, the handler
    ## process is terminated.
    ##
    ## @spec log.overload_kill.max_qlen
    ## ValueType: Integer
    ## Range: [0, 1048576]
    ## Default: 20000
    #max_qlen: 20000

    ## The max allowed memory size before killing the log hanlder.
    ##
    ## Log overload protection parameter. This is the maximum memory size
    ## that the handler process is allowed to use. If the handler grows
    ## larger than this, the process is terminated.
    ##
    ## @spec log.overload_kill.max_mem_size
    ## ValueType: Size
    ## Default: 30MB
    #max_mem_size: 30MB

    ## Restart the log hanlder after some seconds.
    ##
    ## Log overload protection parameter. If the handler is terminated,
    ## it restarts automatically after a delay specified in seconds.
    ## The value "infinity" prevents restarts.
    ##
    ## @spec log.overload_kill.restart_after
    ## ValueType: Duration
    ## Default: 5s
    #restart_after: 5s
  #}

  ## Controlling Bursts of Log Requests.
  ##
  ## Log overload protection parameter. Large bursts of log events - many
  ## events received by the handler under a short period of time - can
  ## potentially cause problems. By specifying the maximum number of events
  ## to be handled within a certain time frame, the handler can avoid
  ## choking the log with massive amounts of printouts.
  ##
  ## Note that there would be no warning if any messages were
  ## dropped because of burst control.
  ##
  ## @spec log.burst_limit_policy
  ## ValueType: Object | disabled
  ## Default: disabled
  #burst_limit_policy {
    ## This config controls the maximum number of events to handle within
    ## a time frame. After the limit is reached, successive events are
    ## dropped until the end of the time frame defined by `window_time`.
    ##
    ## @spec log.burst_limit_policy.max_count
    ## ValueType: Integer
    ## Default: 10000
    #max_count: 10000

    ## See the previous description of burst_limit_max_count.
    ##
    ## @spec log.burst_limit_policy.window_time
    ## ValueType: duration
    ## Default: 1s
    #window_time: 1s
  #}
}

##====================================================================
## RPC
##====================================================================
rpc {
  ## RPC Mode.
  ##
  ## @spec rpc.mode
  ## ValueType: sync | async
  ## Default: async
  mode: async

  ## Max batch size of async RPC requests.
  ##
  ## NOTE: RPC batch won't work when rpc.mode = sync
  ## Zero value disables rpc batching.
  ##
  ## @spec rpc.async_batch_size
  ## ValueType: Integer
  ## Range: [0, 1048576]
  ## Default: 0
  async_batch_size: 256

  ## Number of outgoing RPC connections.
  ##
  ## Defaults to "num_cpu_cores", that is, the number of CPU cores.
  ## Set this to 1 to keep the message order sent from the same client.
  ##
  ## @spec rpc.tcp_client_num
  ## ValueType: Interger | num_cpu_cores
  ## Range: [1, 256]
  ## Defaults: num_cpu_cores
  #tcp_client_num: 1

  ## RCP Client connect timeout.
  ##
  ## @spec rpc.connect_timeout
  ## ValueType: Duration
  ## Default: 5s
  #connect_timeout: 5s

  ## TCP send timeout of RPC client and server.
  ##
  ## @spec rpc.send_timeout
  ## ValueType: Duration
  ## Default: 5s
  #send_timeout: 5s

  ## Authentication timeout
  ##
  ## @spec rpc.authentication_timeout
  ## ValueType: Duration
  ## Default: 5s
  #authentication_timeout: 5s

  ## Default receive timeout for call() functions
  ##
  ## @spec rpc.call_receive_timeout
  ## ValueType: Duration
  ## Default: 15s
  #call_receive_timeout: 15s

  ## Socket idle keepalive.
  ##
  ## @spec rpc.socket_keepalive_idle
  ## ValueType: Duration
  ## Default: 900s
  #socket_keepalive_idle: 900s

  ## TCP Keepalive probes interval.
  ##
  ## @spec rpc.socket_keepalive_interval
  ## ValueType: Duration
  ## Default: 75s
  #socket_keepalive_interval: 75s

  ## Probes lost to close the connection
  ##
  ## @spec rpc.socket_keepalive_count
  ## ValueType: Integer
  ## Default: 9
  #socket_keepalive_count: 9

  ## TCP Options
  ## This will override the global 'tcp_options' config
  ##
  ## @spec rpc.tcp_options
  ## ValueType: ${socket.tcp_options}
  ## Default: ${socket.tcp_options}
  tcp_options: ${socket.tcp_options} {
    sndbuf: 1MB
    recbuf: 1MB
    buffer: 1MB
  }
}

##====================================================================
## Broker
##====================================================================
broker {
  ## System interval of publishing $SYS messages.
  ##
  ## @spec broker.sys_msg_interval
  ## ValueType: Duration
  ## Default: 1m
  sys_msg_interval: 1m

  ## System heartbeat interval of publishing following heart beat message:
  ##  - "$SYS/brokers/<node>/uptime"
  ##  - "$SYS/brokers/<node>/datetime"
  ##
  ## @spec broker.sys_heartbeat_interval
  ## ValueType: Duration
  ## Default: 30s
  sys_heartbeat_interval: 30s

  ## Session locking strategy in a cluster.
  ##
  ## @spec broker.session_locking_strategy
  ## ValueType: local | one | quorum | all
  ##   - local: only lock the session locally on the current node
  ##   - one: select only one remove node to lock the session
  ##   - quorum: select some nodes to lock the session
  ##   - all: lock the session on all of the nodes in the cluster
  ## Default: quorum
  session_locking_strategy: quorum

  ## Dispatch strategy for shared subscription
  ##
  ## @spec broker.shared_subscription_strategy
  ## ValueType: random | round_robin | sticky | hash
  ##   - random: dispatch the message to a random selected subscriber
  ##   - round_robin: select the subscribers in a round-robin manner
  ##   - sticky: always use the last selected subscriber to dispatch,
  ##     until the susbcriber disconnected.
  ##   - hash: select the subscribers by the hash of clientIds
  ## Default: random
  shared_subscription_strategy: random

  ## Enable/disable shared dispatch acknowledgement for QoS1 and QoS2 messages
  ## This should allow messages to be dispatched to a different subscriber in
  ## the group in case the picked (based on shared_subscription_strategy) one # is offline
  ##
  ## @spec broker.shared_dispatch_ack
  ## ValueType: Flag
  ## Default: off
  shared_dispatch_ack: off

  ## Enable batch clean for deleted routes.
  ##
  ## @spec broker.route_batch_clean
  ## ValueType: Flag
  ## Default: off
  route_batch_clean: off
}

##====================================================================
## Listeners
##====================================================================
## MQTT/TCP - TCP Listener for MQTT Protocol
listeners: [
  {
    ## The name of the listener.
    ##
    ## @spec listeners[].name
    ## ValueType: String
    ## Required: true
    name: mqtt_over_tcp

    ## The type of the listener.
    ##
    ## @spec listeners[].type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: tcp

    ## The IP address and port that the listener will bind.
    ##
    ## @spec listeners.[].bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 1883, 127.0.0.1:1883, ::1:1883
    bind: "0.0.0.0:1883"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @spec listeners[].zone
    ## ValueType: String
    ## Default: "default"
    #mqtt: ${mqtt} {
      #max_frame_size: xx
    #}

    ## The size of the acceptor pool for this listener.
    ##
    ## @spec listeners[].acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## TCP backlog defines the maximum length that the queue of
    ## pending connections can grow to.
    ##
    ## @spec listeners[].backlog
    ## ValueType: Number
    ## Range: [0, 1048576]
    ## Default: 128
    #backlog: 1024

    ## Maximum connections per second.
    ##
    ## @spec listeners[].max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    ## Example:
    ##   max_conn_rate: 1000
    #max_conn_rate: no_limit

    ## Maximum number of concurrent connections.
    ##
    ## @spec listeners[].max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @spec listeners[].access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @spec listeners[].active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @spec listeners[].proxy_protocol
    ## ValueType: Flag
    ## Default: on
    #proxy_protocol: on

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @spec listeners[].proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## TCP Options
    ## This will override the global 'tcp_options' config
    ##
    ## @spec rpc.tcp_options
    ## ValueType: ${socket.tcp_options}
    ## Default: ${socket.tcp_options}
    tcp_options: ${socket.tcp_options}
  },

  ## MQTT/SSL - SSL Listener for MQTT Protocol
  {
    ## The name of the listener.
    ##
    ## @spec listeners[].name
    ## ValueType: String
    ## Required: true
    name: mqtt_over_ssl

    ## The type of the listener.
    ##
    ## @spec listeners[].type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: ssl

    ## The IP address and port that the listener will bind.
    ##
    ## @spec listeners.[].bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8883, 127.0.0.1:8883, ::1:8883
    bind: "0.0.0.0:8883"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @spec listeners[].zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The size of the acceptor pool for this listener.
    ##
    ## @spec listeners[].acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @spec listeners[].max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @spec listeners[].max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @spec listeners[].access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @spec listeners[].active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @spec listeners[].proxy_protocol
    ## ValueType: Flag
    ## Default: on
    #proxy_protocol: on

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @spec listeners[].proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## SSL Options
    ## This will override the global 'ssl_options' config
    ##
    ## @spec cluster.etcd.ssl_options
    ## ValueType: ${socket.ssl_options}
    ## Default: ${socket.ssl_options}
    ssl_options: ${socket.ssl_options}

    ## TCP Options
    ## This will override the global 'tcp_options' config
    ##
    ## @spec rpc.tcp_options
    ## ValueType: ${socket.tcp_options}
    ## Default: ${socket.tcp_options}
    tcp_options: ${socket.tcp_options}
  },

  {
    ## The name of the listener.
    ##
    ## @spec listeners[].name
    ## ValueType: String
    ## Required: true
    name: mqtt_over_ws

    ## The type of the listener.
    ##
    ## @spec listeners[].type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: ws

    ## The IP address and port that the listener will bind.
    ##
    ## @spec listeners.[].bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8083, 127.0.0.1:8083, ::1:8083
    bind: "0.0.0.0:8083"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @spec listeners[].zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The path of WebSocket MQTT endpoint
    ##
    ## @spec listeners[].mqtt_path
    ## ValueType: Path
    ## Default: "/mqtt"
    mqtt_path: /mqtt

    ## The size of the acceptor pool for this listener.
    ##
    ## @spec listeners[].acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @spec listeners[].max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @spec listeners[].max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @spec listeners[].access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @spec listeners[].active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @spec listeners[].proxy_protocol
    ## ValueType: Flag
    ## Default: on
    #proxy_protocol: on

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @spec listeners[].proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## Whether a WebSocket message is allowed to contain multiple MQTT packets
    ##
    ## @spec listeners[].mqtt_piggyback
    ## ValueType: single | multiple
    ## Default: multiple
    #mqtt_piggyback: multiple

    ## TCP Options
    ## This will override the global 'tcp_options' config
    ##
    ## @spec rpc.tcp_options
    ## ValueType: ${socket.tcp_options}
    ## Default: ${socket.tcp_options}
    tcp_options: ${socket.tcp_options}

    ## Websocket Options
    ## This will override the global 'websocket_options' config
    ##
    ## @spec rpc.websocket_options
    ## ValueType: ${socket.websocket_options}
    ## Default: ${socket.websocket_options}
    websocket_options: ${socket.websocket_options}
  },

  {
    ## The name of the listener.
    ##
    ## @spec listeners[].name
    ## ValueType: String
    ## Required: true
    name: mqtt_over_wss

    ## The type of the listener.
    ##
    ## @spec listeners[].type
    ## ValueType: tcp | ssl | ws | wss
    ##   - tcp: MQTT over TCP
    ##   - ssl: MQTT over TLS
    ##   - ws:  MQTT over Websocket
    ##   - wss: MQTT over WebSocket Secure
    ## Required: true
    type: wss

    ## The IP address and port that the listener will bind.
    ##
    ## @spec listeners.[].bind
    ## ValueType: IPAddress | Port | IPAddrPort
    ## Required: true
    ## Examples: 8084, 127.0.0.1:8084, ::1:8084
    bind: "0.0.0.0:8084"

    ## The MQTT connection configs this listener will use.
    ##
    ## All the clients connected to this listener will use the MQTT
    ## configs defined by the specific zone name.
    ## See 'mqtt.conf' for details of all MQTT zones.
    ##
    ## It will use the "default" zone if not set.
    ## @spec listeners[].zone
    ## ValueType: String
    ## Default: "default"
    #zone: default

    ## The path of WebSocket MQTT endpoint
    ##
    ## @spec listeners[].mqtt_path
    ## ValueType: Path
    ## Default: "/mqtt"
    mqtt_path: /mqtt

    ## The size of the acceptor pool for this listener.
    ##
    ## @spec listeners[].acceptors
    ## ValueType: Number | num_cpu_cores
    ## Default: num_cpu_cores
    #acceptors: 8

    ## Maximum connections per second.
    ##
    ## @spec listeners[].max_conn_rate
    ## ValueType: Number | no_limit
    ## Default: no_limit
    #max_conn_rate: 1000

    ## Maximum number of concurrent connections.
    ##
    ## @spec listeners[].max_connections
    ## ValueType: Number | no_limit
    ## Default: no_limit
    max_connections: 1024000

    ## The access control rules for this listener.
    ##
    ## See: https://github.com/emqtt/esockd#allowdeny
    ##
    ## @spec listeners[].access_rules
    ## ValueType: Array<AccessRules>
    ## Default: []
    ## Example:
    ##   access_rules: [
    ##     deny 192.168.0.0/24,
    ##     all all
    ##   ]
    #access_rules: [
    #    allow all
    #]

    ## Specify the {active, N} option for this Socket.
    ##
    ## See: https://erlang.org/doc/man/inet.html#setopts-2
    ##
    ## @spec listeners[].active_n
    ## ValueType: Number
    ## Default: 100
    #active_n: 100

    ## Enable the Proxy Protocol V1/2 if the EMQ X cluster is deployed
    ## behind HAProxy or Nginx.
    ##
    ## See: https://www.haproxy.com/blog/haproxy/proxy-protocol/
    ##
    ## @spec listeners[].proxy_protocol
    ## ValueType: Flag
    ## Default: on
    #proxy_protocol: on

    ## Sets the timeout for proxy protocol. EMQ X will close the TCP connection
    ## if no proxy protocol packet recevied within the timeout.
    ##
    ## @spec listeners[].proxy_protocol_timeout
    ## ValueType: Duration
    ## Default: 3s
    #proxy_protocol_timeout: 3s

    ## Whether a WebSocket message is allowed to contain multiple MQTT packets
    ##
    ## @spec listeners[].mqtt_piggyback
    ## ValueType: single | multiple
    ## Default: multiple
    #mqtt_piggyback: multiple

    ## SSL Options
    ## This will override the global 'ssl_options' config
    ##
    ## @spec cluster.etcd.ssl_options
    ## ValueType: ${socket.ssl_options}
    ## Default: ${socket.ssl_options}
    ssl_options: ${socket.ssl_options}

    ## TCP Options
    ## This will override the global 'tcp_options' config
    ##
    ## @spec rpc.tcp_options
    ## ValueType: ${socket.tcp_options}
    ## Default: ${socket.tcp_options}
    tcp_options: ${socket.tcp_options}

    ## Websocket Options
    ## This will override the global 'websocket_options' config
    ##
    ## @spec rpc.websocket_options
    ## ValueType: ${socket.websocket_options}
    ## Default: ${socket.websocket_options}
    websocket_options: ${socket.websocket_options}
  },

  #@ This is an example listener which has less "strict" MQTT settings.
  #@ It's useful to clients connecting the broker from trusted networks.
  {
    name: internal_mqtt_over_tcp
    type: tcp
    bind: "127.0.0.1:11883"
    acceptors: 4
    max_connections: 1024000
    max_conn_rate: 1000
    active_n: 1000
    backlog: 512
    mqtt: ${mqtt} {
      bypass_auth: on
      max_packet_size: 2MB
      max_inflight: 128
      max_awaiting_rel: 1000
      max_mqueue_len: 10000
      enable_acl: off
    }
  }
]

##====================================================================
## Global Socket Options
##====================================================================
socket {
  ## Socket options for TCP connections
  ## See: http://erlang.org/doc/man/inet.html
  tcp_options {
    ## The TCP send timeout for the connections.
    ##
    ## @spec socket.tcp_options.send_timeout
    ## ValueType: Duration
    ## Default: 15s
    send_timeout: 15s

    ## Close the connection if send timeout.
    ##
    ## @spec socket.tcp_options.send_timeout_close
    ## ValueType: Flag
    ## Default: on
    #send_timeout_close: on

    ## The TCP receive buffer(os kernel) for the connections.
    ##
    ## @spec socket.tcp_options.recbuf
    ## ValueType: Size
    ## Default: 4KB
    recbuf: 4KB

    ## The TCP send buffer(os kernel) for the connections.
    ##
    ## @spec socket.tcp_options.sndbuf
    ## ValueType: Size
    ## Default: 4KB
    sndbuf: 4KB

    ## The size of the user-level software buffer used by the driver.
    ##
    ## @spec socket.tcp_options.buffer
    ## ValueType: Size
    ## Default: 4KB
    buffer: 4KB

    ## Sets the 'buffer: max(sndbuf, recbuf)' if this option is enabled.
    ##
    ## @spec socket.tcp_options.tune_buffer
    ## ValueType: Flag
    ## Default: off
    #tune_buffer: off

    ## The TCP_NODELAY flag for the connections.
    ##
    ## @spec socket.tcp_options.nodelay
    ## ValueType: Flag
    ## Default: on
    #nodelay: on

    ## The SO_REUSEADDR flag for the connections.
    ##
    ## @spec socket.tcp_options.reuseaddr
    ## ValueType: Flag
    ## Default: on
    #reuseaddr: on
  }

  ## Socket options for SSL connections
  ## See: http://erlang.org/doc/man/ssl.html
  ssl_options {
    ## A performance optimization setting, it allows clients to reuse
    ## pre-existing sessions, instead of initializing new ones.
    ## Read more about it here.
    ##
    ## @spec socket.tcp_options.reuse_sessions
    ## ValueType: Flag
    ## Default: on
    reuse_sessions: on

    ## SSL parameter renegotiation is a feature that allows a client and a server
    ## to renegotiate the parameters of the SSL connection on the fly.
    ## RFC 5746 defines a more secure way of doing this. By enabling secure renegotiation,
    ## you drop support for the insecure renegotiation, prone to MitM attacks.
    ##
    ## @spec socket.tcp_options.secure_renegotiate
    ## ValueType: Flag
    ## Default: off
    #secure_renegotiate: off

    ## An important security setting, it forces the cipher to be set based
    ## on the server-specified order instead of the client-specified order,
    ## hence enforcing the (usually more properly configured) security
    ## ordering of the server administrator.
    ##
    ## @spec socket.tcp_options.honor_cipher_order
    ## ValueType: Flag
    ## Default: on
    #honor_cipher_order: on

    ## TLS versions only to protect from POODLE attack.
    ##
    ## @spec socket.tcp_options.tls_versions
    ## ValueType: Array<TLSVersion>
    ## Default: [tlsv1.2,tlsv1.1,tlsv1]
    #tls_versions: [tlsv1.2,tlsv1.1,tlsv1]

    ## TLS Handshake timeout.
    ##
    ## @spec socket.tcp_options.handshake_timeout
    ## ValueType: Duration
    ## Default: 15s
    handshake_timeout: 15s

    ## Path to the file containing the user's private PEM-encoded key.
    ##
    ## @spec socket.tcp_options.keyfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/key.pem"
    keyfile: "{{ platform_etc_dir }}/certs/key.pem"

    ## Path to a file containing the user certificate.
    ##
    ## @spec socket.tcp_options.certfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cert.pem"
    certfile: "{{ platform_etc_dir }}/certs/cert.pem"

    ## Path to the file containing PEM-encoded CA certificates. The CA certificates
    ## are used during server authentication and when building the client certificate chain.
    ##
    ## @spec socket.tcp_options.cacertfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/cacert.pem"
    cacertfile: "{{ platform_etc_dir }}/certs/cacert.pem"

    ## The Ephemeral Diffie-Helman key exchange is a very effective way of
    ## ensuring Forward Secrecy by exchanging a set of keys that never hit
    ## the wire. Since the DH key is effectively signed by the private key,
    ## it needs to be at least as strong as the private key. In addition,
    ## the default DH groups that most of the OpenSSL installations have
    ## are only a handful (since they are distributed with the OpenSSL
    ## package that has been built for the operating system it’s running on)
    ## and hence predictable (not to mention, 1024 bits only).
    ## In order to escape this situation, first we need to generate a fresh,
    ## strong DH group, store it in a file and then use the option above,
    ## to force our SSL application to use the new DH group. Fortunately,
    ## OpenSSL provides us with a tool to do that. Simply run:
    ## openssl dhparam -out dh-params.pem 2048
    ##
    ## @spec socket.tcp_options.dhfile
    ## ValueType: File
    ## Default: "{{ platform_etc_dir }}/certs/dh-params.pem"
    #dhfile: "{{ platform_etc_dir }}/certs/dh-params.pem"

    ## A server only does x509-path validation in mode verify_peer,
    ## as it then sends a certificate request to the client (this
    ## message is not sent if the verify option is verify_none).
    ## You can then also want to specify option fail_if_no_peer_cert.
    ## More information at: http://erlang.org/doc/man/ssl.html
    ##
    ## @spec socket.tcp_options.verify
    ## ValueType: verify_peer | verify_none
    ## Default: verify_none
    #verify: verify_peer

    ## Used together with {verify, verify_peer} by an SSL server. If set to true,
    ## the server fails if the client does not have a certificate to send, that is,
    ## sends an empty certificate.
    ##
    ## @spec socket.tcp_options.fail_if_no_peer_cert
    ## ValueType: Flag
    ## Default: on
    #fail_if_no_peer_cert: on

    ## This is the single most important configuration option of an Erlang SSL
    ## application. Ciphers (and their ordering) define the way the client and
    ## server encrypt information over the wire, from the initial Diffie-Helman
    ## key exchange, the session key encryption ## algorithm and the message
    ## digest algorithm. Selecting a good cipher suite is critical for the
    ## application’s data security, confidentiality and performance.
    ##
    ## The cipher list above offers:
    ##
    ## A good balance between compatibility with older browsers.
    ## It can get stricter for Machine-To-Machine scenarios.
    ## Perfect Forward Secrecy.
    ## No old/insecure encryption and HMAC algorithms
    ##
    ## Most of it was copied from Mozilla’s Server Side TLS article
    ##
    ## @spec socket.tcp_options.ciphers
    ## ValueType: Array<Cipher>
    ## Default: [ECDHE-ECDSA-AES256-GCM-SHA384,ECDHE-RSA-AES256-GCM-SHA384,ECDHE-ECDSA-AES256-SHA384,ECDHE-RSA-AES256-SHA384,ECDHE-ECDSA-DES-CBC3-SHA,ECDH-ECDSA-AES256-GCM-SHA384,ECDH-RSA-AES256-GCM-SHA384,ECDH-ECDSA-AES256-SHA384,ECDH-RSA-AES256-SHA384,DHE-DSS-AES256-GCM-SHA384,DHE-DSS-AES256-SHA256,AES256-GCM-SHA384,AES256-SHA256,ECDHE-ECDSA-AES128-GCM-SHA256,ECDHE-RSA-AES128-GCM-SHA256,ECDHE-ECDSA-AES128-SHA256,ECDHE-RSA-AES128-SHA256,ECDH-ECDSA-AES128-GCM-SHA256,ECDH-RSA-AES128-GCM-SHA256,ECDH-ECDSA-AES128-SHA256,ECDH-RSA-AES128-SHA256,DHE-DSS-AES128-GCM-SHA256,DHE-DSS-AES128-SHA256,AES128-GCM-SHA256,AES128-SHA256,ECDHE-ECDSA-AES256-SHA,ECDHE-RSA-AES256-SHA,DHE-DSS-AES256-SHA,ECDH-ECDSA-AES256-SHA,ECDH-RSA-AES256-SHA,AES256-SHA,ECDHE-ECDSA-AES128-SHA,ECDHE-RSA-AES128-SHA,DHE-DSS-AES128-SHA,ECDH-ECDSA-AES128-SHA,ECDH-RSA-AES128-SHA,AES128-SHA]
    #ciphers: []

    ## Ciphers for TLS PSK. See 'https://tools.ietf.org/html/rfc4279#section-2'.
    ##
    ## Note that 'ciphers' and 'psk_ciphers' cannot be configured at the same time.
    ##
    ## @spec socket.tcp_options.ciphers
    ## ValueType: Array<Cipher>
    ## Default: [PSK-AES128-CBC-SHA,PSK-AES256-CBC-SHA,PSK-3DES-EDE-CBC-SHA,PSK-RC4-SHA]
    #psk_ciphers: []
  }

  ## Socket options for websocket connections
  websocket_options {
    ## The compress flag for external WebSocket connections.
    ##
    ## If this Value is set true,the websocket message would be compressed
    ##
    ## @spec socket.websocket_options.compress
    ## ValueType: Flag
    ## Default: on
    #compress: on

    ## The idle timeout for external WebSocket connections.
    ##
    ## @spec socket.websocket_options.idle_timeout
    ## ValueType: Duration | infinity
    ## Default: infinity
    idle_timeout: infinity

    ## The max frame size for external WebSocket connections.
    ##
    ## @spec socket.websocket_options.max_frame_size
    ## ValueType: Size
    ## Default: no_limit
    max_frame_size: no_limit

    #deflate_opts {
      ## The level of deflate options for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.level
      ## ValueType: none | default | best_compression | best_speed
      ## Default: default
      #level: default

      ## The mem_level of deflate options for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.mem_level
      ## ValueType: Integer
      ## Range: [1,9]
      ## Default: 8
      #mem_level: 8

      ## The strategy of deflate options for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.strategy
      ## ValueType: default | filtered | huffman_only | rle
      ## Default: default
      #strategy: default

      ## The deflate option for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.server_context_takeover
      ## ValueType: takeover | no_takeover
      ## Default: takeover
      #server_context_takeover: takeover

      ## The deflate option for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.client_context_takeover
      ## ValueType: takeover | no_takeover
      ## Default: takeover
      #client_context_takeover: takeover

      ## The deflate options for external WebSocket connections.
      ##
      ##
      ## @spec socket.websocket_options.deflate_opts.server_max_window_bits
      ## ValueType: Integer
      ## Range: [8,15]
      ## Default: 15
      #server_max_window_bits: 15

      ## The deflate options for external WebSocket connections.
      ##
      ## @spec socket.websocket_options.deflate_opts.client_max_window_bits
      ## ValueType: Integer
      ## Range: [8,15]
      ## Default: 15
      #client_max_window_bits: 15
    #}
  }
}

##====================================================================
## MQTT Protocol
##====================================================================
mqtt {
  ## Maximum MQTT packet size allowed.
  ##
  ## @spec mqtt.max_packet_size
  ## ValueType: Bytes
  ## Default: 1MB
  max_packet_size: 1MB

  ## Maximum length of MQTT clientId allowed.
  ##
  ## @spec mqtt.max_clientid_len
  ## ValueType: Integer
  ## Range: [23, 65535]
  ## Default: 65535
  #max_clientid_len: 65535

  ## Maximum topic levels allowed.
  ##
  ## @spec mqtt.max_topic_levels
  ## ValueType: Integer | no_limit
  ## Range: [1, 65535]
  ## Default: no_limit
  #max_topic_levels: no_limit

  ## Maximum QoS allowed.
  ##
  ## @spec mqtt.max_qos_allowed
  ## ValueType: 0 | 1 | 2
  ## Default: 2
  #max_qos_allowed: 2

  ## Maximum Topic Alias, 0 means no topic alias supported.
  ##
  ## @spec mqtt.max_topic_alias
  ## ValueType: Integer
  ## Range: [0, 65535]
  ## Default: 65535
  #max_topic_alias: 65535

  ## Whether the Server supports MQTT retained messages.
  ##
  ## @spec mqtt.retain_message
  ## ValueType: Flag
  ## Default: on
  #retain_message: on

  ## Whether the Server supports MQTT Wildcard Subscriptions
  ##
  ## @spec mqtt.wildcard_subscription
  ## ValueType: Flag
  ## Default: on
  #wildcard_subscription: on

  ## Whether the Server supports MQTT Shared Subscriptions.
  ##
  ## @spec mqtt.shared_subscription
  ## ValueType: Flag
  ## Default: on
  #shared_subscription: on

  ## Whether to ignore loop delivery of messages.(for mqtt v3.1.1)
  ##
  ## @spec mqtt.ignore_loop_deliver
  ## ValueType: Flag
  ## Default: off
  #ignore_loop_deliver: off

  ## Whether to parse the MQTT frame in strict mode
  ##
  ## @spec mqtt.strict_mode
  ## ValueType: Flag
  ## Default: off
  #strict_mode: off

  ## Specify the response information returned to the client
  ##
  ## This feature is disabled if not set
  ##
  ## @spec mqtt.response_information
  ## ValueType: String
  ## Default: null
  #response_information: null

  ## Specify the flapping detect policy.
  ##
  ## This config controls the allowed maximum number of CONNECT received
  ## from the same clientid in a time frame defined by `window_time`.
  ## After the limit is reached, successive CONNECT requests are forbidden
  ## (banned) until the end of the time period defined by `ban_time`.
  ## @spec mqtt.flapping_detect_policy
  ## ValueType: Object | disabled
  ## Default: disabled
  #flapping_detect_policy {
    ## The max disconnect allowed of a MQTT Client in `window_time`
    ##
    ## @spec mqtt.flapping_detect_policy.max_count
    ## ValueType: Integer
    ## Default: 5
    #max_count: 5

    ## The time window for flapping detect
    ##
    ## @spec mqtt.flapping_detect_policy.window_time
    ## ValueType: Duration
    ## Default: 10s
    #window_time: 10s

    ## How long the clientid will be banned
    ##
    ## @spec mqtt.flapping_detect_policy.ban_time
    ## ValueType: Duration
    ## Default: 5m
    #ban_time: 5m
  #}

  ## Idle timeout of the external MQTT connections.
  ##
  ## @spec mqtt.idle_timeout
  ## ValueType: Duration
  ## Default: 15s
  idle_timeout: 15s

  ## Enable ACL check.
  ##
  ## @spec mqtt.enable_acl
  ## ValueType: Flag
  ## Default: on
  enable_acl: on

  ## Default ACL File.
  ##
  ## @spec mqtt.internal_acl_file
  ## ValueType: File
  ## Default: "{{ platform_etc_dir }}/acl.conf"
  #internal_acl_file: "{{ platform_etc_dir }}/acl.conf"

  ## Whether to enable ACL cache.
  ##
  ## If enabled, ACLs roles for each client will be cached in the memory
  ##
  ## @spec mqtt.enable_acl_cache
  ## ValueType: Flag
  ## Default: on
  enable_acl_cache: on

  ## The maximum count of ACL entries can be cached for a client.
  ##
  ## @spec mqtt.acl_cache_max_size
  ## ValueType: Integer
  ## Range: [0, 1048576]
  ## Default: 32
  #acl_cache_max_size: 32

  ## The time after which an ACL cache entry will be deleted
  ##
  ## @spec mqtt.acl_cache_ttl
  ## ValueType: Duration
  ## Default: 1m
  #acl_cache_ttl: 1m

  ## The action when acl check reject current operation
  ##
  ## @spec mqtt.acl_deny_action
  ## ValueType: ignore | disconnect
  ## Default: ignore
  #acl_deny_action: ignore

  ## Enable ban check.
  ##
  ## @spec mqtt.enable_ban
  ## ValueType: Flag
  ## Default: on
  #enable_ban: on

  ## Enable per connection statistics.
  ##
  ## @spec mqtt.enable_stats
  ## ValueType: Flag
  ## Default: on
  #enable_stats: on

  ## Force the MQTT connection process GC after this number of
  ## messages | bytes passed through.
  ##
  ## @spec mqtt.force_gc_policy
  ## ValueType: Object | disabled
  ## Default: disabled
  #force_gc_policy: {
    ## Force the MQTT connection process GC after this number of
    ## messages passed through.
    ##
    ## @spec mqtt.force_gc_policy.num_message
    ## ValueType: Integer
    ## Range: (0, 1048576]
    ## Default: 16000
    #num_message: 16000

    ## Force the MQTT connection process GC after this bytes
    ## of messages passed through.
    ##
    ## @spec mqtt.force_gc_policy.bytes
    ## ValueType: Size
    ## Default: 16MB
    #bytes: 16MB
  #}

  ## Max message queue length and total heap size to force shutdown
  ## connection/session process.
  ## Message queue here is the Erlang process mailbox, but not the number
  ## of queued MQTT messages of QoS 1 and 2.
  ##
  ## Default:
  ##   - 10000|64MB on ARCH_64 system
  ##   - 1000|32MB  on ARCH_32 sytem
  ## @spec mqtt.force_shutdown_policy
  ## ValueType: Object | disabled
  ## Default: disabled
  #force_shutdown_policy: {
    ## Max message queue length
    ## @spec mqtt.force_shutdown_policy.max_message_queue_len
    ## ValueType: Integer
    ## Range: (0, )
    ## Default: system-architecture
    ##   - arch_64: 10000
    ##   - arch_32: 1000
    #max_message_queue_len: 1000

    ## Total heap size
    ##
    ## @spec mqtt.force_shutdown_policy.max_heap_size
    ## ValueType: Size
    ## Default: system-architecture
    ##   - arch_64: 64MB
    ##   - arch_32: 32MB
    #max_heap_size: 32MB
  #}

  ## Server Keep Alive of MQTT 5.0
  ##
  ## @spec mqtt.server_keepalive
  ## ValueType: Number | disabled
  ## Default: disabled
  #server_keepalive: disabled

  ## The backoff for MQTT keepalive timeout. The broker will kick a connection out
  ## until 'Keepalive * backoff * 2' timeout.
  ##
  ## @spec mqtt.keepalive_backoff
  ## ValueType: Float
  ## Range: (0.5, 1]
  ## Default: 0.75
  #keepalive_backoff: 0.75

  ## Maximum number of subscriptions allowed, 0 means no limit.
  ##
  ## @spec mqtt.max_subscriptions
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: no_limit
  #max_subscriptions: no_limit

  ## Force to upgrade QoS according to subscription.
  ##
  ## @spec mqtt.upgrade_qos
  ## ValueType: Flag
  ## Default: off
  #upgrade_qos: off

  ## Maximum size of the Inflight Window storing QoS1/2 messages delivered but unacked.
  ##
  ## @spec mqtt.max_inflight
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 32
  #max_inflight: 32

  ## Retry interval for QoS1/2 message delivering.
  ##
  ## @spec mqtt.retry_interval
  ## ValueType: Duration
  ## Default: 30s
  #retry_interval: 30s

  ## Maximum QoS2 packets (Client -> Broker) awaiting PUBREL, 0 means no limit.
  ##
  ## @spec mqtt.max_awaiting_rel
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 100
  #max_awaiting_rel: 100

  ## The QoS2 messages (Client -> Broker) will be dropped if awaiting PUBREL timeout.
  ##
  ## @spec mqtt.await_rel_timeout
  ## ValueType: Duration
  ## Default: 300s
  #await_rel_timeout: 300s

  ## Default session expiry interval for MQTT V3.1.1 connections.
  ##
  ## @spec mqtt.session_expiry_interval
  ## ValueType: Duration
  ## Default: 2h
  #session_expiry_interval: 2h

  ## Maximum queue length. Enqueued messages when persistent client disconnected,
  ## or inflight window is full. 0 means no limit.
  ##
  ## @spec mqtt.max_mqueue_len
  ## ValueType: Integer | no_limit
  ## Range: [0, )
  ## Default: 1000
  #max_mqueue_len: 1000

  ## Topic priorities.
  ##
  ## There's no priority table by default, hence all messages
  ## are treated equal.
  ## The top topicname in the table has the highest priority, and then
  ## the next one has the second highest priority, etc.
  ## Messages for topics not in the priority table are treated as
  ## either highest or lowest priority depending on the configured
  ## value for mqtt.mqueue_default_priority
  ##
  ## @spec mqtt.mqueue_priorities
  ## ValueType: Array<TopicName>
  ## Example:
  ##  To configure "t/1" > "t/2" > "t/3":
  ##  mqueue_priorities: [t/1,t/2,t/3]
  ## Default: []
  #mqueue_priorities: []

  ## Default to highest priority for topics not matching priority table
  ##
  ## @spec mqtt.mqueue_default_priority
  ## ValueType: highest | lowest
  ## Default: highest
  #mqueue_default_priority: highest

  ## Whether to enqueue QoS0 messages.
  ##
  ## @spec mqtt.mqueue_store_qos0
  ## ValueType: Flag
  ## Default: on
  #mqueue_store_qos0: on

  ## Prefix all topics with the mountpoint string.
  ##
  ## Variables in mountpoint path:
  ##  - %c: clientid
  ##  - %u: username
  ##
  ## @spec mqtt.mountpoint
  ## ValueType: String | null
  ## Default: null
  #mountpoint: null

  ## Force the clients to bypass authentication step
  ##
  ## @spec mqtt.bypass_auth
  ## ValueType: Flag
  ## Default: off
  #bypass_auth: off

  ## Whether use username replace client id
  ##
  ## @spec mqtt.use_username_as_clientid
  ## ValueType: Flag
  ## Default: off
  #use_username_as_clientid: off

  ## Use the CN, DN or CRT field from the client certificate as a username.
  ## Only works for SSL connection.
  ##
  ## @spec mqtt.peer_cert_as_username
  ## ValueType: cn | dn | crt | disabled
  ## Default: disabled
  #peer_cert_as_username: disabled

  ## Limit the message rate
  ##
  ## @spec mqtt.rate_limit_policy
  ## ValueType: Object | disabled
  ## Default: disabled
  #rate_limit_policy {
    ## Limit the rate of receiving messages for a MQTT connection.
    ## The rate is counted by the number of messages in per second.
    ##
    ## The connection won't accept more messages if the messages come
    ## faster than the limit.
    ##
    ## @spec mqtt.rate_limit_policy.max_messages_in_rate
    ## ValueType: Integer | no_limit
    ## Range: [0, )
    ## Example: 100 messages per second:
    ##   messages_in: 100
    #max_messages_in_rate: no_limit

    ## Limit the rate of receiving packets for a MQTT connection.
    ## The rate is counted by bytes of packets per second.
    ##
    ## The connection won't accept more messages if the messages come
    ## faster than the limit.
    ##
    ## @spec mqtt.rate_limit_policy.max_bytes_in_rate
    ## ValueType: Size | no_limit
    ## Example: 100KB incoming per second:
    ##   bytes_in: 100KB
    ##
    #max_bytes_in_rate: no_limit

    ## ?????????
    ## Limit the rate of forwarding MQTT messages to the subscribers
    ## for a MQTT client.
    ## The rate is counted by the number of messages per second.
    ##
    ## The broker won't forward more messages for that client if the
    ## messages come faster than the limit.
    ##
    ## @spec mqtt.rate_limit_policy.messages_forwarding
    ## ValueType: Size | no_limit
    ## Range: (0, )
    ## Example: 100 messages per second:
    ##   messages_forwarding: 100
    #messages_forwarding: no_limit

    ## ????
    ## Messages quota for the all of external MQTT connections.
    ## This value consumed by the number of recipient on a message.
    ##
    ## @spec mqtt.rate_limit_policy.messages_forwarding_overall
    ## ValueType: Number | no_limit
    ## Range: (0, )
    ## Example: 200000 messages per second:
    ## messages_forwarding_overall: 200000
    ##
    #messages_forwarding_overall: no_limit
  #}
}

##====================================================================
## System Monitor
##====================================================================
#sysmon {
  ## The time interval for the periodic process limit check
  ##
  ## @spec sysmon.process_check_interval
  ## ValueType: Duration
  ## Default: 30s
  #process_check_interval: 30s

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is set.
  ##
  ## @spec sysmon.process_high_watermark
  ## ValueType: Percentage
  ## Default: 80%
  #process_high_watermark: 80%

  ## The threshold, as percentage of processes, for how many processes can simultaneously exist at the local node before the corresponding alarm is clear.
  ##
  ## @spec sysmon.process_low_watermark
  ## ValueType: Percentage
  ## Default: 60%
  #process_low_watermark: 60%

  ## Enable Long GC monitoring.
  ## Notice: don't enable the monitor in production for:
  ## https://github.com/erlang/otp/blob/feb45017da36be78d4c5784d758ede619fa7bfd3/erts/emulator/beam/erl_gc.c#L421
  ##
  ## @spec sysmon.long_gc
  ## ValueType: Duration | disabled
  ## Default: disabled
  #long_gc: 50ms

  ## Enable Long Schedule(ms) monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @spec sysmon.long_schedule
  ## ValueType: Duration | disabled
  ## Default: disabled
  #long_schedule: 240ms

  ## Enable Large Heap monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @spec sysmon.large_heap
  ## ValueType: Size | disabled
  ## Default: Depends on system-architecture
  ##   - arch_64: 32MB
  ##   - arch_32: 64MB
  #large_heap: 32MB

  ## Enable Busy Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @spec sysmon.busy_port
  ## ValueType: Flag
  ## Default: on
  #busy_port: on

  ## Enable Busy Dist Port monitoring.
  ##
  ## See: http://erlang.org/doc/man/erlang.html#system_monitor-2
  ##
  ## @spec sysmon.busy_dist_port
  ## ValueType: Flag
  ## Default: on
  #busy_dist_port: on

  ## The time interval for the periodic cpu check
  ##
  ## @spec sysmon.cpu_check_interval
  ## ValueType: Duration
  ## Default: 60s
  #cpu_check_interval: 60s

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is set.
  ##
  ## @spec sysmon.cpu_high_watermark
  ## ValueType: Percentage
  ## Default: 80%
  #cpu_high_watermark: 80%

  ## The threshold, as percentage of system cpu, for how much system cpu can be used before the corresponding alarm is clear.
  ##
  ## @spec sysmon.cpu_low_watermark
  ## ValueType: Percentage
  ## Default: 60%
  #cpu_low_watermark: 60%

  ## The time interval for the periodic memory check
  ##
  ## @spec sysmon.mem_check_interval
  ## ValueType: Duration | disabled
  ## Default: 60s
  #mem_check_interval: 60s

  ## The threshold, as percentage of system memory, for how much system memory can be allocated before the corresponding alarm is set.
  ##
  ## @spec sysmon.sysmem_high_watermark
  ## ValueType: Percentage
  ## Default: 70%
  #sysmem_high_watermark: 70%

  ## The threshold, as percentage of system memory, for how much system memory can be allocated by one Erlang process before the corresponding alarm is set.
  ##
  ## @spec sysmon.procmem_high_watermark
  ## ValueType: Percentage
  ## Default: 5%
  #procmem_high_watermark: 5%
#}

##====================================================================
## Alarm
##====================================================================
#alarm {
  ## Specifies the actions to take when an alarm is activated
  ##
  ## @spec sysmon.actions
  ## ValueType: Array<AlarmAction>
  ## Default: [log, publish]
  #actions: [log, publish]

  ## The maximum number of deactivated alarms
  ##
  ## @spec sysmon.size_limit
  ## ValueType: Integer
  ## Default: 1000
  #size_limit: 1000

  ## Validity Period of deactivated alarms
  ##
  ## @spec sysmon.validity_period
  ## ValueType: Duration
  ## Default: 24h
  #validity_period: 24h
#}
